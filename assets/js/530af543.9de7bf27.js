"use strict";(self.webpackChunkrouter_docs=self.webpackChunkrouter_docs||[]).push([[9662],{3905:(e,n,t)=>{t.d(n,{Zo:()=>l,kt:()=>m});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var c=a.createContext({}),u=function(e){var n=a.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},l=function(e){var n=u(e.components);return a.createElement(c.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},p=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,l=s(e,["components","mdxType","originalType","parentName"]),p=u(t),m=r,h=p["".concat(c,".").concat(m)]||p[m]||d[m]||i;return t?a.createElement(h,o(o({ref:n},l),{},{components:t})):a.createElement(h,o({ref:n},l))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=p;var s={};for(var c in n)hasOwnProperty.call(n,c)&&(s[c]=n[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var u=2;u<i;u++)o[u]=t[u];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}p.displayName="MDXCreateElement"},87689:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>i,metadata:()=>s,toc:()=>u});var a=t(87462),r=(t(67294),t(3905));const i={title:"SudoMsg",sidebar_position:2},o=void 0,s={unversionedId:"message-transfer-via-crosstalk/router-chain-guides/iDapp-functions/sudomsg",id:"message-transfer-via-crosstalk/router-chain-guides/iDapp-functions/sudomsg",title:"SudoMsg",description:"The SudoMsg is an enum with two different message types:",source:"@site/docs/develop/message-transfer-via-crosstalk/router-chain-guides/iDapp-functions/sudomsg.md",sourceDirName:"message-transfer-via-crosstalk/router-chain-guides/iDapp-functions",slug:"/message-transfer-via-crosstalk/router-chain-guides/iDapp-functions/sudomsg",permalink:"/develop/message-transfer-via-crosstalk/router-chain-guides/iDapp-functions/sudomsg",draft:!1,editUrl:"https://github.com/router-protocol/docs/tree/main/docs/develop/message-transfer-via-crosstalk/router-chain-guides/iDapp-functions/sudomsg.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"SudoMsg",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"RouterMsg",permalink:"/develop/message-transfer-via-crosstalk/router-chain-guides/iDapp-functions/routermsg"},next:{title:"Stateful (OmniChain) Bridging",permalink:"/develop/message-transfer-via-crosstalk/stateful-bridging/"}},c={},u=[],l={toc:u};function d(e){let{components:n,...t}=e;return(0,r.kt)("wrapper",(0,a.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"SudoMsg")," is an enum with two different message types:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"HandleIReceive")," (akin to ",(0,r.kt)("inlineCode",{parentName:"li"},"iReceive")," for EVM chains)"),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"HandleIAck")," (akin to ",(0,r.kt)("inlineCode",{parentName:"li"},"iAck")," for EVM chains)")),(0,r.kt)("p",null,"To have a better understanding of the format in which the data will be received, we have added field-level details of ",(0,r.kt)("inlineCode",{parentName:"p"},"SudoMsg"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = "snake_case")]\npub enum SudoMsg {\n    // Sudo msg to handle incoming requests from other chains\n    HandleIReceive {\n        // the inbound initiator application contract address\n        request_sender: String,\n        // inbound request src chain id\n        source_chain_id: String,\n        // inbound request event nonce\n        request_identifier: u64,\n        // the inbound request instructions in base64 format\n        payload: Binary,\n    },\n    // Sudo msg to handle outbound message acknowledgment\n    HandleIAck {\n        // cross-chain request nonce\n        request_identifier: u64,\n        // cross-chain request contract call execution status\n        exec_flag: u64,\n        // cross-chain request contract call execution\n        exec_data: Binary,\n        // excess fee refunded amount\n        refund_amount: Coin,\n    },\n}\n')),(0,r.kt)("p",null,"The ",(0,r.kt)("inlineCode",{parentName:"p"},"sudo")," function is one of the entry-points in a CosmWasm contract. For contracts on the Router chain, you need to implement this function to receive any incoming request. It can be called internally by the chain only (just like ",(0,r.kt)("inlineCode",{parentName:"p"},"iReceive")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"iAck")," on other chains can only be called by the Router Gateway contract). Sample implementation:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'// import router binding message\nuse router_wasm_bindings::{RouterMsg, SudoMsg};\n\n#[cfg_attr(not(feature = "library"), entry_point)]\npub fn sudo(deps: DepsMut, _env: Env, msg: SudoMsg) -> StdResult<Response<RouterMsg>> {\n    match msg {\n        // Sudo msg to handle incoming requests from other chains\n        SudoMsg::HandleIReceive {\n            request_sender,\n            src_chain_id,\n            request_identifier,\n            payload,\n        } => handle_sudo_request(\n            deps,\n            env,\n            request_sender,\n            src_chain_id,\n            request_identifier,\n            payload,\n        ),\n        // Sudo msg to handle outbound message acknowledgment\n        SudoMsg::HandleIAck {\n            request_identifier,\n            exec_flag,\n            exec_data,\n            refund_amount,\n        } => handle_sudo_ack(\n            deps,\n            env,\n            request_identifier,\n            exec_flag,\n            exec_data,\n            refund_amount,\n        ),\n    }\n}\n')),(0,r.kt)("p",null,"Developers can implement their own business logic inside the ",(0,r.kt)("inlineCode",{parentName:"p"},"handle_sudo_request")," and ",(0,r.kt)("inlineCode",{parentName:"p"},"handle_sudo_ack")," functions."),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("b",null,"HandleIReceive")),(0,r.kt)("p",null,"The sudo message ",(0,r.kt)("inlineCode",{parentName:"p"},"HandleIReceive")," contains 4 arguments. This message type is used whenever any generic cross-chain request is received. As you can see in the code snippet, a function ",(0,r.kt)("inlineCode",{parentName:"p"},"handle_sudo_request")," has been created to handle the incoming request in the CosmWasm contact. Within this function, you can apply your custom logic to handle the payload.  Each field has its own purpose and meaning in the ",(0,r.kt)("inlineCode",{parentName:"p"},"HandleIReceive")," request."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"1) ",(0,r.kt)("inlineCode",{parentName:"strong"},"request_sender")," -")," The application contract address on the source chain from which the request to the Router chain was sent."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"2) ",(0,r.kt)("inlineCode",{parentName:"strong"},"source_chain_id")," -")," The network ID of the chain from which the cross-chain request to the Router chain has been initiated."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"3) ",(0,r.kt)("inlineCode",{parentName:"strong"},"request_identifier")," -")," A unique identifier of the request that is added by the source chain's Gateway contract."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"4) ",(0,r.kt)("inlineCode",{parentName:"strong"},"payload")," -")," The payload received from the source chain contract. "),(0,r.kt)("p",null,"After handling the incoming cross-chain request, if you wish, you can generate an outgoing cross-chain reques. More about this is given ",(0,r.kt)("a",{parentName:"p",href:"../../stateful-bridging"},"here"),".")),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("b",null,"HandleIAck")),(0,r.kt)("p",null,"The sudo message ",(0,r.kt)("inlineCode",{parentName:"p"},"HandleIAck")," has 4 arguments. This message type is used whenever any acknowledgment is received. As you can see in the code snippet, a function named ",(0,r.kt)("inlineCode",{parentName:"p"},"handle_sudo_ack")," has been created to handle the incoming acknowledgment request in the CosmWasm contact. Each field has its own purpose and meaning in the ",(0,r.kt)("inlineCode",{parentName:"p"},"HandleIAck")," request."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"1) ",(0,r.kt)("inlineCode",{parentName:"strong"},"request_identifier")," -")," This is same nonce you receive while calling the ",(0,r.kt)("inlineCode",{parentName:"p"},"CrosschainCall")," function on the Router chain.\nUsing this nonce, you can map the acknowledgmemnt to a particular request. "),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"2) ",(0,r.kt)("inlineCode",{parentName:"strong"},"exec_flag")," -")," A boolean value that tells you the status of your cross-chain request. "),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"3) ",(0,r.kt)("inlineCode",{parentName:"strong"},"exec_data")," -")," The execution data for all the contract calls executed on the destination chain."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"4) ",(0,r.kt)("inlineCode",{parentName:"strong"},"refund_amount")," -")," The surplus fee that was sent for the destination side contract execution.")))}d.isMDXComponent=!0}}]);