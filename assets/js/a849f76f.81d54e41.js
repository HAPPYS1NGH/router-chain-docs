"use strict";(self.webpackChunkrouter_docs=self.webpackChunkrouter_docs||[]).push([[6653],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>u});var a=n(67294);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,o=function(e,t){if(null==e)return{};var n,a,o={},s=Object.keys(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(a=0;a<s.length;a++)n=s[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},p=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,o=e.mdxType,s=e.originalType,l=e.parentName,p=i(e,["components","mdxType","originalType","parentName"]),d=c(n),u=o,h=d["".concat(l,".").concat(u)]||d[u]||m[u]||s;return n?a.createElement(h,r(r({ref:t},p),{},{components:n})):a.createElement(h,r({ref:t},p))}));function u(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var s=n.length,r=new Array(s);r[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:o,r[1]=i;for(var c=2;c<s;c++)r[c]=n[c];return a.createElement.apply(null,r)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},38774:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>s,metadata:()=>i,toc:()=>c});var a=n(87462),o=(n(67294),n(3905));const s={title:"How to Use the CrossTalkUtils Library",sidebar_position:2},r=void 0,i={unversionedId:"crosstalkutils-library/how-to-use-the-crosstalkutils-library",id:"crosstalkutils-library/how-to-use-the-crosstalkutils-library",title:"How to Use the CrossTalkUtils Library",description:"1) Import the CrossTalkUtils library in your Contract",source:"@site/docs/crosstalk/crosstalkutils-library/how-to-use-the-crosstalkutils-library.md",sourceDirName:"crosstalkutils-library",slug:"/crosstalkutils-library/how-to-use-the-crosstalkutils-library",permalink:"/crosstalk/crosstalkutils-library/how-to-use-the-crosstalkutils-library",draft:!1,editUrl:"https://github.com/router-protocol/docs/tree/main/docs/crosstalk/crosstalkutils-library/how-to-use-the-crosstalkutils-library.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"How to Use the CrossTalkUtils Library",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"CrossTalkUtils Library",permalink:"/crosstalk/crosstalkutils-library/"},next:{title:"Helper Functions",permalink:"/crosstalk/crosstalkutils-library/helper-functions"}},l={},c=[{value:"1) Import the CrossTalkUtils library in your Contract",id:"1-import-the-crosstalkutils-library-in-your-contract",level:3},{value:"2) Call the Required Function",id:"2-call-the-required-function",level:3},{value:"(a) Single Call without Acknowledgment",id:"a-single-call-without-acknowledgment",level:4},{value:"(b) Single Call with Acknowledgment",id:"b-single-call-with-acknowledgment",level:4},{value:"(c) Multiple Calls without Acknowledgment",id:"c-multiple-calls-without-acknowledgment",level:4},{value:"(c) Multiple Calls with Acknowledgment",id:"c-multiple-calls-with-acknowledgment",level:4}],p={toc:c};function m(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h3",{id:"1-import-the-crosstalkutils-library-in-your-contract"},"1) Import the CrossTalkUtils library in your Contract"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},'pragma solidity 0.8.x;\nimport "@routerprotocol/router-crosstalk-utils/contracts/CrossTalkUtils.sol";\ncontract MyContract {}\n')),(0,o.kt)("h3",{id:"2-call-the-required-function"},"2) Call the Required Function"),(0,o.kt)("p",null,"Demonstration for different kinds of requests:"),(0,o.kt)("h4",{id:"a-single-call-without-acknowledgment"},"(a) Single Call without Acknowledgment"),(0,o.kt)("p",null,"Consider an application that allows users to transfer their ERC20 tokens from one chain to another. In this case, the requirements are as follows:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"We need to send a single contract call for execution to the destination chain contract."),(0,o.kt)("li",{parentName:"ol"},"We don't need the acknowledgment back on the source chain after the contract call is executed on the destination chain.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"function singleRequestWithoutAcknowledgement(\n    address gatewayContract,\n    uint64 expiryTimestamp,\n    Utils.DestinationChainParams memory destChainParams, \n    bytes memory destinationContractAddress, \n    bytes memory payload\n) internal returns(uint64)\n")),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("b",null,"To implement such functionality using CrossTalkUtils library, follow these steps:")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Step 1) Call the ",(0,o.kt)("inlineCode",{parentName:"strong"},"singleRequestWithoutAcknowledgement")," Function on the CrossTalkUtils Library")),(0,o.kt)("p",null," To create a cross-chain request from the source chain, we will call the CrossTalkUtils library's ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"singleRequestWithoutAcknowledgement"))," function."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"uint64 nonce = CrossTalkUtils.singleRequestWithoutAcknowledgement(\n    gatewayContractAddress, // in address format\n    expiryTimestamp, // uint64\n    destinationChainParams, // format given in point 3 below\n    destinationContractAddress, // in bytes\n    payload // bytes\n);\n")),(0,o.kt)("p",null,"While calling the ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"singleRequestWithoutAcknowledgement"))," function on the CrossTalkUtils library, we need to pass the following parameters:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"gatewayContractAddress:")," The address of the Router's Gateway contract."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"expiryTimestamp:")," The timestamp by which your cross-chain call will expire. If your call is not executed on the destination chain by this time, it will be reverted. If you don't want any expiry timestamp, pass ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"type(uint64).max"))," as the expiryTimestamp."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"destinationChainParams:")," We need to pass the destination chain gas limit, gas price, chain type, and the chain ID here.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"    struct Utils.DestinationChainParams(\n        uint64 gasLimit, \n        uint64 gasPrice, \n        uint64 destChainType, \n        string memory destChainId\n)\n")),(0,o.kt)("ol",{start:4},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"destinationContractAddress:")," Address of the contract on the destination chain to which the payload should be sent. This address should be in bytes format. You can use the ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"toBytes"))," function in the library to convert the address to bytes format.",(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"bytes memory destinationContractAddress = toBytes(contractAddress);\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"payload:")," The payload that you want to send to the destination chain. This should be of type bytes.")),(0,o.kt)("p",null,"In this way, we can create a cross-chain communication request without acknowledgement. This function will return the nonce of the transaction."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Step 2) Handle the Cross-chain Request in your Destination Contract")),(0,o.kt)("p",null,"Once the cross-chain request is received on the destination chain, we need a mechanism to handle it. That's where ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"handleRequestFromSource"))," function comes into play. Router's Gateway contract on the destination chain will pass the payload along with the source chain details to the destination chain contract by calling this function."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"function handleRequestFromSource(\n      bytes memory srcContractAddress,\n      bytes memory payload,\n      string memory srcChainId,\n      uint64 srcChainType\n) external returns (bytes memory)\n")),(0,o.kt)("p",null,"You can handle the payload in any way you want to complete your cross-chain functionality."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Step 3) Adding an Empty Acknowledgment Handler")),(0,o.kt)("p",null,"Even though we don't need an acknowledgment on the source chain, we need to implement an acknowledgment handler function. This will be empty since this function will never get called in this particular use case. The documentation for this function can be found ",(0,o.kt)("a",{parentName:"p",href:"../understanding-crosstalk/handleCrossTalkAck"},"here"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"function handleCrossTalkAck(\n  uint64, // eventIdentifier\n  bool[] memory, // execFlags\n  bytes[] memory // execData\n) external {}\n"))),(0,o.kt)("h4",{id:"b-single-call-with-acknowledgment"},"(b) Single Call with Acknowledgment"),(0,o.kt)("p",null,"Consider an application that allows users to send a message (ping) from the source chain and receive a message in response (pong) from the destination chain. In this case, the requirements are as follows:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"We need to send a single contract call for execution to the destination chain contract."),(0,o.kt)("li",{parentName:"ol"},"We need an acknowledgment back on the source chain after the contract call is executed on the destination chain.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"function singleRequestWithAcknowledgement(\n    address gatewayContract,\n    uint64 expiryTimestamp,\n    Utils.AckType ackType,\n    Utils.AckGasParams memory ackGasParams,\n    Utils.DestinationChainParams memory destChainParams, \n    bytes memory destinationContractAddress, \n    bytes memory payload\n) internal returns(uint64)\n")),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("b",null,"To implement such functionality using CrossTalkUtils library, follow these steps:")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Step 1) Call the ",(0,o.kt)("inlineCode",{parentName:"strong"},"singleRequestWithAcknowledgement")," Function on the CrossTalkUtils Library")),(0,o.kt)("p",null," To create a cross-chain request from the source chain, we will call the CrossTalkUtils library's ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"singleRequestWithAcknowledgement"))," function."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"uint64 nonce = CrossTalkUtils.singleRequestWithAcknowledgement(\n    gatewayContract, // in address format\n    expiryTimestamp, // uint64\n    ackType, // Format given in point 3 below\n ackGasParams, // Format given in point 4 below\n    destinationChainParams, // Format given in point 5 below\n    destinationContractAddress, // in bytes\n    payload // in bytes\n);\n")),(0,o.kt)("p",null,"While calling the ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"singleRequestWithAcknowledgement"))," function on the CrossTalkUtils library, we need to pass the following parameters:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"gatewayContractAddress:")," The address of the Router's Gateway contract.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"expiryTimestamp:")," The timestamp by which your cross-chain call will expire. If your call is not executed on the destination chain by this time, it will be reverted. If you don't want any expiry timestamp, pass ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"type(uint64).max"))," as the expiryTimestamp.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"ackType:")),(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},"Set this to ",(0,o.kt)("strong",{parentName:"li"},"ACK_ON_SUCCESS")," if you only want to get acknowledgment when the execution on the destination chain is successful."),(0,o.kt)("li",{parentName:"ol"},"Set this to ",(0,o.kt)("strong",{parentName:"li"},"ACK_ON_ERROR")," if you only want to get acknowledgment when the execution on the destination chain failed."),(0,o.kt)("li",{parentName:"ol"},"Set this to ",(0,o.kt)("strong",{parentName:"li"},"ACK_ON_BOTH")," if you want to get acknowledgment in both the cases (success and failure).")),(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Format:")),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"enum Utils.AckType(NO_ACK, ACK_ON_SUCCESS, ACK_ON_ERROR, ACK_ON_BOTH)\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"ackGasParams:")),(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"ackGasLimit:")," Gas limit for execution of the function ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"handleCrossTalkAck"))," on the source chain."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"ackGasPrice:")," Gas price with which you want to execute the aforementioned function on the source chain.")),(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Format:")),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"struct Utils.AckGasParams(uint64 ackGasLimit, uint64 ackGasPrice)\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"destinationChainParams:")," We need to pass the destination chain gas limit, gas price, chain type, and the chain ID here."))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"    struct Utils.DestinationChainParams(\n        uint64 gasLimit, \n        uint64 gasPrice, \n        uint64 destChainType, \n        string memory destChainId\n)\n")),(0,o.kt)("ol",{start:6},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"destinationContractAddress:")," Address of the contract on the destination chain to which the payload should be sent. This address should be in bytes format. You can use the ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"toBytes"))," function in the library to convert the address to bytes format.",(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"bytes memory destinationContractAddress = toBytes(contractAddress);\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"payload:")," The payload that you want to send to the destination chain. This should be of type bytes.")),(0,o.kt)("p",null,"In this way, we can create a cross-chain communication request with acknowledgement. This function will return the nonce of the transaction."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Step 2) Handle the Cross-chain Request in your Destination Contract")),(0,o.kt)("p",null,"Once the cross-chain request is received on the destination chain, we need a mechanism to handle it. That's where ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"handleRequestFromSource"))," function comes into play. Router's Gateway contract on the destination chain will pass the payload along with the source chain details to the destination chain contract by calling this function."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"function handleRequestFromSource(\n      bytes memory srcContractAddress,\n      bytes memory payload,\n      string memory srcChainId,\n      uint64 srcChainType\n) external returns (bytes memory)\n")),(0,o.kt)("p",null,"You can handle the payload in any way you want to complete your cross-chain functionality."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Step 3) Adding an Acknowledgment Handler")),(0,o.kt)("p",null,"Since we are anticipating an acknowledgment on the source chain, we need to implement an acknowledgment handler function.  This will be contain the logic to handle the acknowledgement, i.e., what you want to do on the source chain post the execution of the request on the destination chain. The documentation for this function can be found ",(0,o.kt)("a",{parentName:"p",href:"../understanding-crosstalk/handleCrossTalkAck"},"here"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"function handleCrossTalkAck(\n  uint64 eventIdentifier,\n  bool[] memory execFlags,\n  bytes[] memory execData\n) external\n"))),(0,o.kt)("h4",{id:"c-multiple-calls-without-acknowledgment"},"(c) Multiple Calls without Acknowledgment"),(0,o.kt)("p",null,"Consider an application that allows users to transfer multiple ERC20 tokens or messages from one chain to another in the same cross-chain request. In this case, the requirements are as follows:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"We need to send multiple contract calls for execution to the destination chain contract."),(0,o.kt)("li",{parentName:"ol"},"We don't need the acknowledgment back on the source chain after the calls are executed on the destination chain.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"function multipleRequestsWithoutAcknowledgement(\n    address gatewayContract,\n    uint64 expiryTimestamp,\n    bool isAtomicCalls,\n    Utils.DestinationChainParams memory destChainParams, \n    bytes[] memory destinationContractAddresses, \n    bytes[] memory payloads\n) internal returns(uint64)\n")),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("b",null,"To implement such functionality using CrossTalkUtils library, follow these steps:")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Step 1) Call the ",(0,o.kt)("inlineCode",{parentName:"strong"},"multipleRequestsWithoutAcknowledgement")," Function on the CrossTalkUtils Library")),(0,o.kt)("p",null," To create a cross-chain request from the source chain, we will call the CrossTalkUtils library's ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"multipleRequestsWithoutAcknowledgement"))," function."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"   uint64 nonce = CrossTalkUtils.multipleRequestsWithoutAcknowledgement(\n    gatewayContract, // in address format\n    expiryTimestamp, // uint64\n    isAtomicCalls, // bool \n    destinationChainParams, // format given in point 4 below\n    destinationContractAddresses, // in bytes array format\n    payloads // in bytes array format\n);\n")),(0,o.kt)("p",null,"While calling the ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"multipleRequestsWithoutAcknowledgement"))," function on the CrossTalkUtils library, we need to pass the following parameters:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"gatewayContractAddress:")," The address of the Router's Gateway contract."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"expiryTimestamp:")," The timestamp by which your cross-chain call will expire. If your call is not executed on the destination chain by this time, it will be reverted. If you don't want any expiry timestamp, pass ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"type(uint64).max"))," as the expiryTimestamp."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"isAtomicCalls"),": Set it to true if you want to ensure that either all your contract calls are executed or none of them are executed. Set it to false if you do not require atomicity. "),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"destinationChainParams:")," We need to pass the destination chain gas limit, gas price, chain type, and the chain ID here.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"    struct Utils.DestinationChainParams(\n        uint64 gasLimit, \n        uint64 gasPrice, \n        uint64 destChainType, \n        string memory destChainId\n)\n")),(0,o.kt)("ol",{start:5},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"destinationContractAddresses:")," Addresses of the contracts on the destination chain to which the individual payloads should be sent. These addresses should be in bytes format. You can use the ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"toBytes"))," function in the library to convert the address to bytes format. The array of destination contract addresses can be created in the following way:",(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"bytes memory destinationContractAddress1 = toBytes(contractAddress1);\nbytes memory destinationContractAddress2 = toBytes(contractAddress2);\nbytes[] memory destinationContractAddresses = new bytes[](2);\ndestinationContractAddresses[0] = destinationContractAddress1;\ndestinationContractAddresses[1] = destinationContractAddress2;\n")),"For simplicity, we have only used two destination contract addresses in this example. You can send as many addresses as you want."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"payload:")," The payloads you want to send to the respective destination contract addresses. These should be of type bytes. The array of payloads can be created in the following way:",(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"bytes[] memory payloads = new bytes[](2);\npayloads[0] = payload1;\npayload[1] = payload2;\n")),"For simplicity, we have only used two payloads in this example. You can send as many payloads as you want as long as the number of payloads should is equal to the number of destination contract addresses.")),(0,o.kt)("p",null,"In this way, we can create a cross-chain communication request without acknowledgement. This function will return the nonce of the transaction."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Step 2) Handle the Cross-chain Request in your Destination Contract")),(0,o.kt)("p",null,"Once the cross-chain request is received on the destination chain, we need a mechanism to handle it. That's where ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"handleRequestFromSource"))," function comes into play. Router's Gateway contract on the destination chain will pass the payload along with the source chain details to the respective destination chain contract by calling this function."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"function handleRequestFromSource(\n      bytes memory srcContractAddress,\n      bytes memory payload,\n      string memory srcChainId,\n      uint64 srcChainType\n) external returns (bytes memory)\n")),(0,o.kt)("p",null,"You can handle the payload in any way you want to complete your cross-chain functionality."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Step 3) Adding an Empty Acknowledgment Handler")),(0,o.kt)("p",null,"Even though we don't need an acknowledgment on the source chain, we need to implement an acknowledgment handler function. This will be empty since this function will never get called in this particular use case. The documentation for this function can be found ",(0,o.kt)("a",{parentName:"p",href:"../understanding-crosstalk/handleCrossTalkAck"},"here"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"function handleCrossTalkAck(\n  uint64, // eventIdentifier\n  bool[] memory, // execFlags\n  bytes[] memory // execData\n) external {}\n"))),(0,o.kt)("h4",{id:"c-multiple-calls-with-acknowledgment"},"(c) Multiple Calls with Acknowledgment"),(0,o.kt)("p",null,"Consider an application that allows users to send multiple messages (pings) from the source chain and receive a message in response (pong) to all those messages from the destination chain. In this case, the requirements are as follows:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"We need to send multiple contract calls for execution to the destination chain contract."),(0,o.kt)("li",{parentName:"ol"},"We need an acknowledgment back on the source chain after the calls are executed on the destination chain.")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"function multipleRequestsWithAcknowledgement(\n    address gatewayContract,\n    uint64 expiryTimestamp,\n    bool isAtomicCalls,\n    Utils.AckType ackType,\n    Utils.AckGasParams memory ackGasParams,\n    Utils.DestinationChainParams memory destChainParams, \n    bytes[] memory destinationContractAddresses, \n    bytes[] memory payloads\n) internal returns(uint64)\n")),(0,o.kt)("details",null,(0,o.kt)("summary",null,(0,o.kt)("b",null,"To implement such functionality using CrossTalkUtils library, follow these steps:")),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Step 1) Call the ",(0,o.kt)("inlineCode",{parentName:"strong"},"multipleRequestsWithAcknowledgement")," Function on the CrossTalkUtils Library")),(0,o.kt)("p",null," To create a cross-chain request from the source chain, we will call the CrossTalkUtils library's ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"multipleRequestsWithAcknowledgement"))," function."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"   uint64 nonce = CrossTalkUtils.multipleRequestsWithoutAcknowledgement(\n    gatewayContract, // in address format\n    expiryTimestamp, // uint64\n    isAtomicCalls, // bool \n    destinationChainParams, // format given in point 4 below\n    destinationContractAddresses, // in bytes array format\n    payloads // in bytes array format\n);\n")),(0,o.kt)("p",null,"While calling the ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"multipleRequestsWithAcknowledgement"))," function on the CrossTalkUtils library, we need to pass the following parameters:"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"gatewayContractAddress:")," The address of the Router's Gateway contract.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"expiryTimestamp:")," The timestamp by which your cross-chain call will expire. If your call is not executed on the destination chain by this time, it will be reverted. If you don't want any expiry timestamp, pass ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"type(uint64).max"))," as the expiryTimestamp.")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"isAtomicCalls"),": Set it to true if you want to ensure that either all your contract calls are executed or none of them are executed. Set it to false if you do not require atomicity. ")),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"ackType:")),(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},"Set this to ",(0,o.kt)("strong",{parentName:"li"},"ACK_ON_SUCCESS")," if you only want to get acknowledgment when the execution on the destination chain is successful."),(0,o.kt)("li",{parentName:"ol"},"Set this to ",(0,o.kt)("strong",{parentName:"li"},"ACK_ON_ERROR")," if you only want to get acknowledgment when the execution on the destination chain failed."),(0,o.kt)("li",{parentName:"ol"},"Set this to ",(0,o.kt)("strong",{parentName:"li"},"ACK_ON_BOTH")," if you want to get acknowledgment in both the cases (success and failure).")),(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Format:")),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"enum Utils.AckType(NO_ACK, ACK_ON_SUCCESS, ACK_ON_ERROR, ACK_ON_BOTH)\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"ackGasParams:")),(0,o.kt)("ol",{parentName:"li"},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"ackGasLimit:")," Gas limit for execution of the function ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"handleCrossTalkAck"))," on the source chain."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"ackGasPrice:")," Gas price with which you want to execute the aforementioned function on the source chain.")),(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"Format:")),(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"struct Utils.AckGasParams(uint64 ackGasLimit, uint64 ackGasPrice)\n"))),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("p",{parentName:"li"},(0,o.kt)("strong",{parentName:"p"},"destinationChainParams:")," We need to pass the destination chain gas limit, gas price, chain type, and the chain ID here."))),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"    struct Utils.DestinationChainParams(\n        uint64 gasLimit, \n        uint64 gasPrice, \n        uint64 destChainType, \n        string memory destChainId\n)\n")),(0,o.kt)("ol",{start:7},(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"destinationContractAddresses:")," Addresses of the contracts on the destination chain to which the individual payloads should be sent. These addresses should be in bytes format. You can use the ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"toBytes"))," function in the library to convert the address to bytes format. The array of destination contract addresses can be created in the following way:",(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"bytes memory destinationContractAddress1 = toBytes(contractAddress1);\nbytes memory destinationContractAddress2 = toBytes(contractAddress2);\nbytes[] memory destinationContractAddresses = new bytes[](2);\ndestinationContractAddresses[0] = destinationContractAddress1;\ndestinationContractAddresses[1] = destinationContractAddress2;\n")),"For simplicity, we have only used two destination contract addresses in this example. You can send as many addresses as you want."),(0,o.kt)("li",{parentName:"ol"},(0,o.kt)("strong",{parentName:"li"},"payload:")," The payloads you want to send to the respective destination contract addresses. These should be of type bytes. The array of payloads can be created in the following way:",(0,o.kt)("pre",{parentName:"li"},(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"bytes[] memory payloads = new bytes[](2);\npayloads[0] = payload1;\npayload[1] = payload2;\n")),"For simplicity, we have only used two payloads in this example. You can send as many payloads as you want as long as the number of payloads should is equal to the number of destination contract addresses.")),(0,o.kt)("p",null,"In this way, we can create a cross-chain communication request with acknowledgement. This function will return the nonce of the transaction."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Step 2) Handle the Cross-chain Request in your Destination Contract")),(0,o.kt)("p",null,"Once the cross-chain request is received on the destination chain, we need a mechanism to handle it. That's where ",(0,o.kt)("strong",{parentName:"p"},(0,o.kt)("inlineCode",{parentName:"strong"},"handleRequestFromSource"))," function comes into play. Router's Gateway contract on the destination chain will pass the payload along with the source chain details to the respective destination chain contract by calling this function."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"function handleRequestFromSource(\n      bytes memory srcContractAddress,\n      bytes memory payload,\n      string memory srcChainId,\n      uint64 srcChainType\n) external returns (bytes memory)\n")),(0,o.kt)("p",null,"You can handle the payload in any way you want to complete your cross-chain functionality."),(0,o.kt)("p",null,(0,o.kt)("strong",{parentName:"p"},"Step 3) Adding an Acknowledgment Handler")),(0,o.kt)("p",null,"Since we are anticipating an acknowledgment on the source chain, we need to implement an acknowledgment handler function.  This will be contain the logic to handle the acknowledgement, i.e., what you want to do on the source chain post the execution of the request on the destination chain. The documentation for this function can be found ",(0,o.kt)("a",{parentName:"p",href:"../understanding-crosstalk/handleCrossTalkAck"},"here"),"."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-javascript"},"function handleCrossTalkAck(\n  uint64 eventIdentifier,\n  bool[] memory execFlags,\n  bytes[] memory execData\n) external\n"))))}m.isMDXComponent=!0}}]);