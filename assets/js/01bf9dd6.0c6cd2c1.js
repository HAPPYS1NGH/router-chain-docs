"use strict";(self.webpackChunkrouter_docs=self.webpackChunkrouter_docs||[]).push([[7713],{3905:(e,t,n)=>{n.d(t,{Zo:()=>l,kt:()=>p});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),u=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},l=function(e){var t=u(e.components);return r.createElement(s.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,s=e.parentName,l=c(e,["components","mdxType","originalType","parentName"]),m=u(n),p=a,h=m["".concat(s,".").concat(p)]||m[p]||d[p]||o;return n?r.createElement(h,i(i({ref:t},l),{},{components:n})):r.createElement(h,i({ref:t},l))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=m;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:a,i[1]=c;for(var u=2;u<o;u++)i[u]=n[u];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},80745:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>c,toc:()=>u});var r=n(87462),a=(n(67294),n(3905));const o={title:"RouterMsg",sidebar_position:2},i=void 0,c={unversionedId:"understanding-omnichain-framework/router-chain-middleware-contract/routermsg",id:"understanding-omnichain-framework/router-chain-middleware-contract/routermsg",title:"RouterMsg",description:"The RouterMsg is an enum type inside the router-wasm-bindings. It contains one custom message type.",source:"@site/docs/omnichain-framework/understanding-omnichain-framework/router-chain-middleware-contract/routermsg.md",sourceDirName:"understanding-omnichain-framework/router-chain-middleware-contract",slug:"/understanding-omnichain-framework/router-chain-middleware-contract/routermsg",permalink:"/omnichain-framework/understanding-omnichain-framework/router-chain-middleware-contract/routermsg",draft:!1,editUrl:"https://github.com/router-protocol/docs/tree/main/docs/omnichain-framework/understanding-omnichain-framework/router-chain-middleware-contract/routermsg.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"RouterMsg",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"SudoMsg",permalink:"/omnichain-framework/understanding-omnichain-framework/router-chain-middleware-contract/sudomsg"},next:{title:"Sample Contracts",permalink:"/omnichain-framework/understanding-omnichain-framework/sample-contracts"}},s={},u=[],l={toc:u};function d(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},l,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"RouterMsg")," is an enum type inside the ",(0,a.kt)("em",{parentName:"p"},"router-wasm-bindings"),". It contains one custom message type."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"OutboundBatchRequests")),(0,a.kt)("p",null,"In the following code snippet, one implementation of ",(0,a.kt)("inlineCode",{parentName:"p"},"OutboundBatchRequests")," has been added. This message is used to create an outbound request. In the outbound request, you can specify the destination chain id & type, the contract addresses & instructions, the request expiry timestamp, the atomicity flag, etc."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},'// import router binding message\nuse router_wasm_bindings::{RouterMsg, SudoMsg};\nuse router_wasm_bindings::types::{\n    ChainType, ContractCall, OutboundBatchRequest, OutboundBatchResponse, OutboundBatchResponses,\n};\n\nlet address: String = String::from("destination_contract_address");\nlet payload: Vec<u8> = let payload: Vec<u8> = b"sample payload data".to_vec();\n// Single Outbound request with single contract call\nlet contract_call: ContractCall = ContractCall {\n    destination_contract_address: address.clone().into_bytes(),\n    payload,\n};\nlet outbound_batch_req: OutboundBatchRequest = OutboundBatchRequest {\n    destination_chain_type: ChainType::ChainTypeEvm.get_chain_code(),\n    destination_chain_id: String::from("137"),\n    contract_calls: vec![contract_call],\n    relayer_fee: Coin {\n        denom: String::from("route"),\n        amount: Uint128::new(100_000u128),\n    },\n    outgoing_tx_fee: Coin {\n        denom: String::from("route"),\n        amount: Uint128::new(100_000u128),\n    },\n    is_atomic: false,\n    exp_timestamp: 1673860261,\n};\nlet outbound_batch_reqs: RouterMsg = RouterMsg::OutboundBatchRequests {\n    outbound_batch_requests: vec![outbound_batch_req]\n};\n\nlet res = Response::new()\n    .add_message(outbound_batch_reqs);\nOk(res)\n')),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"OutboundBatchRequest")," is a data_type that helps the end user to create an outbound request to any destination chain. It has 7 arguments. "),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"destination_chain_type:")," The chain type of the chain for which the outbound request from the Router chain has been created."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"destination_chain_id"),": The chain id of the chain for which the outbound request from the Router chain has been created."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"contract_calls"),": An array of contract calls that need to be executed on the destination chain.  Each Contract Call contains a contract address and a payload for that contract execution."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"relayer_fee"),": A fee that is going to the relayer service for relaying the request on the destination chain gateway contact."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"outgoing_tx_fee"),": A fee that is required to generate an outbound request in the Router chain."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"is_atomic"),": A boolean value that helps the destination chain gateway contact to understand the contract calls atomicity."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"exp_timestamp"),": An expiry timestamp is a number value. If it is less than the current timestamp while execution on the destination chain, the contract calls will not be executed on the destination chain.")),(0,a.kt)("p",null,"Since you are writing the application middleware contracts, you will have complete control over what kind of data is received in the payload. You can define the encoding and decoding of the data accordingly and perform any operation on the data."))}d.isMDXComponent=!0}}]);