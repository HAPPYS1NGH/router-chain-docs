"use strict";(self.webpackChunkrouter_docs=self.webpackChunkrouter_docs||[]).push([[301],{3905:(e,n,t)=>{t.d(n,{Zo:()=>l,kt:()=>h});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=r.createContext({}),p=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},l=function(e){var n=p(e.components);return r.createElement(c.Provider,{value:n},e.children)},d={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},u=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,l=i(e,["components","mdxType","originalType","parentName"]),u=p(t),h=a,f=u["".concat(c,".").concat(h)]||u[h]||d[h]||o;return t?r.createElement(f,s(s({ref:n},l),{},{components:t})):r.createElement(f,s({ref:n},l))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,s=new Array(o);s[0]=u;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var p=2;p<o;p++)s[p]=t[p];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}u.displayName="MDXCreateElement"},38880:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>p});var r=t(87462),a=(t(67294),t(3905));const o={title:"Check and Set Allowances",sidebar_position:2},s=void 0,i={unversionedId:"tools/voyager-pathFinder-api/performing-cross-chain-transaction/check-set-allowance",id:"tools/voyager-pathFinder-api/performing-cross-chain-transaction/check-set-allowance",title:"Check and Set Allowances",description:"Prior to initiating a transaction using any web3 library (ethers.js or web3.js), users must make sure that Router's Reserve Token Handler has the appropriate permissions to use the requested asset in their wallet. You can achieve this via the following piece of code:",source:"@site/docs/voyager/tools/voyager-pathFinder-api/performing-cross-chain-transaction/check-set-allowance.md",sourceDirName:"tools/voyager-pathFinder-api/performing-cross-chain-transaction",slug:"/tools/voyager-pathFinder-api/performing-cross-chain-transaction/check-set-allowance",permalink:"/voyager/tools/voyager-pathFinder-api/performing-cross-chain-transaction/check-set-allowance",draft:!1,editUrl:"https://github.com/router-protocol/docs/tree/main/docs/voyager/tools/voyager-pathFinder-api/performing-cross-chain-transaction/check-set-allowance.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Check and Set Allowances",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Request a Quote",permalink:"/voyager/tools/voyager-pathFinder-api/performing-cross-chain-transaction/request-quote"},next:{title:"Execute the Transaction",permalink:"/voyager/tools/voyager-pathFinder-api/performing-cross-chain-transaction/execute-transaction"}},c={},p=[],l={toc:p};function d(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},l,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Prior to initiating a transaction using any web3 library (ethers.js or web3.js), users must make sure that Router's Reserve Token Handler has the appropriate permissions to use the requested asset in their wallet. You can achieve this via the following piece of code:"),(0,a.kt)("admonition",{type:"note"},(0,a.kt)("p",{parentName:"admonition"},"Router Protocol enables native asset transfers/swaps via their wrapped versions. Therefore, users need to provide an allowance to the wrapped version of the native asset being transferred/swapped.\nNative asset and its wrapped asset info is given ",(0,a.kt)("a",{parentName:"p",href:"../../configurations/native-assets"},"here"),".")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-ts"},'import { ethers, Contract } from \'ethers\'\n\n// ERC20 Contract ABI for "Approve" and "Allowance" functions\nconst erc20_abi = [\n    {\n        "name": "approve",\n        "inputs": [\n            {\n                "internalType": "address",\n                "name": "spender",\n                "type": "address"\n            },\n            {\n                "internalType": "uint256",\n                "name": "amount",\n                "type": "uint256"\n            }\n        ],\n        "outputs": [\n            {\n                "internalType": "bool",\n                "name": "",\n                "type": "bool"\n            }\n        ],\n        "stateMutability": "nonpayable",\n        "type": "function"\n    },\n    {\n        "name": "allowance",\n        "inputs": [\n            {\n                "internalType": "address",\n                "name": "owner",\n                "type": "address"\n            },\n            {\n                "internalType": "address",\n                "name": "spender",\n                "type": "address"\n            }\n        ],\n        "outputs": [\n            {\n                "internalType": "uint256",\n                "name": "",\n                "type": "uint256"\n            }\n        ],\n        "stateMutability": "view",\n        "type": "function"\n    }\n];\n\n// Fetch the current allowance and update if needed\nconst checkAndSetAllowance = async (wallet, tokenAddress, approvalAddress, amount) => {\n    // Transactions with the native token don\'t need approval\n    if (tokenAddress === ethers.constants.AddressZero) {\n        return\n    }\n\n    const erc20 = new Contract(tokenAddress, erc20_abi, wallet);\n    const allowance = await erc20.allowance(await wallet.getAddress(), approvalAddress);\n    if (allowance.lt(amount)) {\n        const approveTx = await erc20.approve(approvalAddress, amount, {gasPrice: await wallet.provider.getGasPrice()});\n        try {\n            await approveTx.wait();\n            console.log(`Transaction mined succesfully: ${approveTx.hash}`)\n        }\n        catch (error) {\n            console.log(`Transaction failed with error: ${error}`)\n        }\n    }\n}\n\nconst main = async () => {\n\n    // setting up a signer\n    const provider = new ethers.providers.JsonRpcProvider("https://polygon-rpc.com", 137);\n    // use provider.getSigner() method to get a signer if you\'re using this for a UI\n    const wallet = new ethers.Wallet("YOUR_PRIVATE_KEY", provider)\n    \n    await checkAndSetAllowance(\n        wallet,\n        \'0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174\', // fromTokenAddress (USDC on Polygon)\n        \'0x6e14f48576265272B6CAA3A7cC500a26050Be64E\', // addressToApprove (Voyager\'s Reserve Token Handler on Polygon)\n        ethers.constants.MaxUint256 // amount to approve (infinite approval)\n    );\n}\n\nmain()\n')))}d.isMDXComponent=!0}}]);