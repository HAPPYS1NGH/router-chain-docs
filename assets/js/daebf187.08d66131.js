"use strict";(self.webpackChunkrouter_docs=self.webpackChunkrouter_docs||[]).push([[383],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>m});var o=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);n&&(o=o.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,o)}return t}function r(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function u(e,n){if(null==e)return{};var t,o,a=function(e,n){if(null==e)return{};var t,o,a={},i=Object.keys(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(o=0;o<i.length;o++)t=i[o],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var s=o.createContext({}),c=function(e){var n=o.useContext(s),t=n;return e&&(t="function"==typeof e?e(n):r(r({},n),e)),t},d=function(e){var n=c(e.components);return o.createElement(s.Provider,{value:n},e.children)},l={inlineCode:"code",wrapper:function(e){var n=e.children;return o.createElement(o.Fragment,{},n)}},h=o.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,d=u(e,["components","mdxType","originalType","parentName"]),h=c(t),m=a,p=h["".concat(s,".").concat(m)]||h[m]||l[m]||i;return t?o.createElement(p,r(r({ref:n},d),{},{components:t})):o.createElement(p,r({ref:n},d))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,r=new Array(i);r[0]=h;var u={};for(var s in n)hasOwnProperty.call(n,s)&&(u[s]=n[s]);u.originalType=e,u.mdxType="string"==typeof e?e:a,r[1]=u;for(var c=2;c<i;c++)r[c]=t[c];return o.createElement.apply(null,r)}return o.createElement.apply(null,t)}h.displayName="MDXCreateElement"},34233:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>r,default:()=>l,frontMatter:()=>i,metadata:()=>u,toc:()=>c});var o=t(87462),a=(t(67294),t(3905));const i={title:"SudoMsg",sidebar_position:1},r=void 0,u={unversionedId:"understanding-omnichain-framework/router-chain-middleware-contract/sudomsg",id:"understanding-omnichain-framework/router-chain-middleware-contract/sudomsg",title:"SudoMsg",description:"The SudoMsg is an enum and it has two different message types.",source:"@site/docs/omnichain-framework/understanding-omnichain-framework/router-chain-middleware-contract/sudomsg.md",sourceDirName:"understanding-omnichain-framework/router-chain-middleware-contract",slug:"/understanding-omnichain-framework/router-chain-middleware-contract/sudomsg",permalink:"/omnichain-framework/understanding-omnichain-framework/router-chain-middleware-contract/sudomsg",draft:!1,editUrl:"https://github.com/router-protocol/docs/tree/main/docs/omnichain-framework/understanding-omnichain-framework/router-chain-middleware-contract/sudomsg.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"SudoMsg",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Functions on Router chain's middleware contract",permalink:"/omnichain-framework/understanding-omnichain-framework/router-chain-middleware-contract/"},next:{title:"RouterMsg",permalink:"/omnichain-framework/understanding-omnichain-framework/router-chain-middleware-contract/routermsg"}},s={},c=[],d={toc:c};function l(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,o.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The ",(0,a.kt)("em",{parentName:"p"},"SudoMsg")," is an enum and it has two different message types."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"HandleInboundReq"),(0,a.kt)("li",{parentName:"ul"},"HandleOutboundAck")),(0,a.kt)("p",null,"In the following code snippet, details at the field level of the ",(0,a.kt)("inlineCode",{parentName:"p"},"SudoMsg")," have been added. This will give you an understanding of the data that will be coming either in the inbound request or in the outbound acknowledgment request."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},'#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, JsonSchema)]\n#[serde(rename_all = "snake_case")]\npub enum SudoMsg {\n    // Sudo msg to handle incoming requests from other chains\n    HandleInboundReq {\n        // the inbound initiator application contract address\n        sender: String,\n        // inbound request src chain type\n        chain_type: u32,\n        // inbound request src chain id\n        source_chain_id: String,\n        // the inbound request instructions in base64 format\n        payload: Binary,\n    },\n    // Sudo msg to handle outbound message acknowledgment\n    HandleOutboundAck {\n        // the outbound request initiator router address\n        outbound_tx_requested_by: String,\n        // outbound request destination chain type\n        destination_chain_type: u32,\n        // outbound request destination chain id\n        destination_chain_id: String,\n        // outbound batch request nonce\n        outbound_batch_nonce: u64,\n        // outbound request execution code info\n        execution_code: u64,\n        // outbound request execution status info\n        execution_status: bool,\n        // outbound request contract calls individual execution status\n        exec_flags: Vec<bool>,\n        // outbound request contract calls individual execution response\n        exec_data: Vec<Binary>,\n    },\n}\n')),(0,a.kt)("p",null,"The sudo function is one of the entry-point in a cosmwasm contract.\nIt can be called internally by the chain only. You need to implement this sudo function in Router Chain to receive an incoming request. Here, in the following code snippet, the sample sudo function implementation is shown."),(0,a.kt)("p",null,"You can have any sort of business logic inside the ",(0,a.kt)("inlineCode",{parentName:"p"},"handle_in_bound_request")," and ",(0,a.kt)("inlineCode",{parentName:"p"},"handle_out_bound_ack_request")," functions."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},'# import router binding message\nuse router_wasm_bindings::{RouterMsg, SudoMsg};\n\n#[cfg_attr(not(feature = "library"), entry_point)]\npub fn sudo(deps: DepsMut, _env: Env, msg: SudoMsg) -> StdResult<Response<RouterMsg>> {\n    match msg {\n        # Sudo msg to handle incoming requests from other chains\n        SudoMsg::HandleInboundReq {\n            sender,\n            chain_type,\n            source_chain_id,\n            payload,\n        } => handle_in_bound_request(deps, sender, chain_type, source_chain_id, payload),\n        # Sudo msg to handle outbound message acknowledgment\n        SudoMsg::HandleOutboundAck {\n            outbound_tx_requested_by,\n            destination_chain_type,\n            destination_chain_id,\n            outbound_batch_nonce,\n            execution_code,\n            execution_status,\n            exec_flags,\n            exec_data,\n        } => handle_out_bound_ack_request(\n            deps,\n            outbound_tx_requested_by,\n            destination_chain_type,\n            destination_chain_id,\n            outbound_batch_nonce,\n            execution_code,\n            execution_status,\n            exec_flags,\n            exec_data,\n        ),\n    }\n}\n')),(0,a.kt)("details",null,(0,a.kt)("summary",null,(0,a.kt)("b",null,"HandleInboundReq")),(0,a.kt)("p",null,"The sudo message ",(0,a.kt)("inlineCode",{parentName:"p"},"HandleInboundReq")," contains 4 arguments. This sudo function gets called when an inbound request comes for your middleware contract. We can handle this sudo request in any possible way or even skip it. As you can see in the code snippet, a function ",(0,a.kt)("inlineCode",{parentName:"p"},"handle_in_bound_request")," has been created to handle the incoming inbound request in the cosmwasm contact. Within this function, you can apply any logic to the payload from the incoming request before creating the request for the destination chain. Each field has its own purpose and meaning in the ",(0,a.kt)("inlineCode",{parentName:"p"},"HandleInboundReq")," request. "),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"sender"),": the application contract address on the source chain from which the request to the Router chain was sent."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"chain_type"),": The chain type of the chain from which the inbound request to the Router chain has been initiated"),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"source_chain_id"),": The chain id of the chain from which the inbound request to the Router chain has been initiated."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"payload"),": The payload comes from the source chain contract."))),(0,a.kt)("details",null,(0,a.kt)("summary",null,(0,a.kt)("b",null,"HandleOutboundAck")),(0,a.kt)("p",null,"The sudo message ",(0,a.kt)("inlineCode",{parentName:"p"},"HandleOutboundAck")," has 8 arguments. This sudo function gets called when the acknowledgment is received by the middleware contract on the Router chain post-execution of the contract calls on the destination chain. We can handle this sudo request in any possible way or even skip it. As you can see in the code snippet, function ",(0,a.kt)("inlineCode",{parentName:"p"},"handle_out_bound_ack_request")," has been created to handle the incoming acknowldgement request in the cosmwasm contact. Each field has its own purpose and meaning in the ",(0,a.kt)("inlineCode",{parentName:"p"},"HandleOutboundAck")," request. "),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"outbound_tx_requested_by"),": The address of the router chain contract that initiated the outbound request from the Router chain."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"destination_chain_type"),":  The chain type of the chain for which the outbound request from the Router chain has been created."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"destination_chain_id"),": The chain id of the chain for which the outbound request from the Router chain has been created."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"outbound_batch_nonce"),": The unique and incremented integer value for the outbound request."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"execution_code"),": The execution code is a number value that helps us in understanding the outbound request execution info on the destination chain."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"execution_status"),": The status is a boolean value that helps us (with execution_code) in understanding the outbound request execution info on the destination chain."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"exec_flags"),": The execution status flags for all the contract calls which were made on the destination chain. This will be an array of all the execution statuses (true/false) for each request on the destination chain."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"exec_data"),": The execution data for all the requests executed on the destination chain."))))}l.isMDXComponent=!0}}]);