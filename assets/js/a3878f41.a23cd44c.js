"use strict";(self.webpackChunkrouter_docs=self.webpackChunkrouter_docs||[]).push([[9688],{3905:(e,n,t)=>{t.d(n,{Zo:()=>u,kt:()=>h});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function s(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?s(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):s(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function i(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},s=Object.keys(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(r=0;r<s.length;r++)t=s[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=r.createContext({}),d=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},u=function(e){var n=d(e.components);return r.createElement(c.Provider,{value:n},e.children)},l={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},m=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,s=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),m=d(t),h=a,f=m["".concat(c,".").concat(h)]||m[h]||l[h]||s;return t?r.createElement(f,o(o({ref:n},u),{},{components:t})):r.createElement(f,o({ref:n},u))}));function h(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var s=t.length,o=new Array(s);o[0]=m;var i={};for(var c in n)hasOwnProperty.call(n,c)&&(i[c]=n[c]);i.originalType=e,i.mdxType="string"==typeof e?e:a,o[1]=i;for(var d=2;d<s;d++)o[d]=t[d];return r.createElement.apply(null,o)}return r.createElement.apply(null,t)}m.displayName="MDXCreateElement"},16673:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>o,default:()=>l,frontMatter:()=>s,metadata:()=>i,toc:()=>d});var r=t(87462),a=(t(67294),t(3905));const s={title:"Creating a Sample Cross-Chain NFT Contract",sidebar_position:1},o=void 0,i={unversionedId:"message-transfer-via-crosstalk/evm-guides/your-first-crosschain-nft-contract/creating-your-nft-contract",id:"message-transfer-via-crosstalk/evm-guides/your-first-crosschain-nft-contract/creating-your-nft-contract",title:"Creating a Sample Cross-Chain NFT Contract",description:"To create cross-chain applications using the Router infrastructure, users will have to build and deploy application contracts on various third-party chains. This section describes how to create a cross-chain NFT smart contract.",source:"@site/docs/develop/message-transfer-via-crosstalk/evm-guides/your-first-crosschain-nft-contract/creating-your-nft-contract.md",sourceDirName:"message-transfer-via-crosstalk/evm-guides/your-first-crosschain-nft-contract",slug:"/message-transfer-via-crosstalk/evm-guides/your-first-crosschain-nft-contract/creating-your-nft-contract",permalink:"/develop/message-transfer-via-crosstalk/evm-guides/your-first-crosschain-nft-contract/creating-your-nft-contract",draft:!1,editUrl:"https://github.com/router-protocol/docs/tree/main/docs/develop/message-transfer-via-crosstalk/evm-guides/your-first-crosschain-nft-contract/creating-your-nft-contract.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Creating a Sample Cross-Chain NFT Contract",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Your First iDapp",permalink:"/develop/message-transfer-via-crosstalk/evm-guides/your-first-crosschain-nft-contract/"},next:{title:"Deploying a Sample Cross-Chain NFT Contract",permalink:"/develop/message-transfer-via-crosstalk/evm-guides/your-first-crosschain-nft-contract/deploying-your-nft-contract"}},c={},d=[{value:"<strong>STEP 1)</strong> Create your Solidity smart contract",id:"step-1-create-your-solidity-smart-contract",level:2},{value:"<strong>STEP 2)</strong> Cross-Chain functions in brief",id:"step-2-cross-chain-functions-in-brief",level:2},{value:"<strong>1)</strong> transferCrossChain Function",id:"1-transfercrosschain-function",level:3},{value:"<strong>2)</strong> IReceive Function",id:"2-ireceive-function",level:3}],u={toc:d};function l(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"To create cross-chain applications using the Router infrastructure, users will have to build and deploy application contracts on various third-party chains. This section describes how to create a cross-chain NFT smart contract."),(0,a.kt)("h2",{id:"step-1-create-your-solidity-smart-contract"},(0,a.kt)("strong",{parentName:"h2"},"STEP 1)")," Create your Solidity smart contract"),(0,a.kt)("p",null,"We simply inherit Openzeppelin's implementations of popular standard ERC1155, and extend the behavior to our needs. To make NFT cross-chain, we import Router Protocol's evm-gateway-contracts and utilise them as shown in the following code."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},'// SPDX-License-Identifier: Unlicensed\npragma solidity >=0.8.0 <0.9.0;\n\nimport "@routerprotocol/evm-gateway-contracts@1.1.11/contracts/IDapp.sol";\nimport "@routerprotocol/evm-gateway-contracts@1.1.11/contracts/IGateway.sol";\nimport "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";\n\n/// @title XERC1155\n/// @notice A cross-chain ERC-1155 smart contract to demonstrate how one can create\n/// cross-chain NFT contracts using Router CrossTalk.\ncontract XERC1155 is ERC1155, IDapp {\n  // address of the owner\n  address public owner;\n\n  // address of the gateway contract\n  IGateway public gatewayContract;\n\n  // chain type + chain id => address of our contract in string format\n  mapping(string => string) public ourContractOnChains;\n\n  // transfer params struct where we specify which NFTs should be transferred to\n  // the destination chain and to which address\n  struct TransferParams {\n    uint256[] nftIds;\n    uint256[] nftAmounts;\n    bytes nftData;\n    bytes recipient;\n  }\n\n  constructor(\n    string memory _uri,\n    address payable gatewayAddress,\n    string memory feePayerAddress\n  ) ERC1155(_uri) {\n    gatewayContract = IGateway(gatewayAddress);\n    owner = msg.sender;\n\n    // minting ourselves some NFTs so that we can test out the contracts\n    _mint(msg.sender, 1, 10, "");\n\n    gatewayContract.setDappMetadata(feePayerAddress);\n  }\n\n  /// @notice function to set the fee payer address on Router Chain.\n  /// @param feePayerAddress address of the fee payer on Router Chain.\n  function setDappMetadata(string memory feePayerAddress) external {\n    require(msg.sender == owner, "only owner");\n    gatewayContract.setDappMetadata(feePayerAddress);\n  }\n\n  /// @notice function to set the Router Gateway Contract.\n  /// @param gateway address of the gateway contract.\n  function setGateway(address gateway) external {\n    require(msg.sender == owner, "only owner");\n    gatewayContract = IGateway(gateway);\n  }\n\n  function mint(\n    address account,\n    uint256[] memory nftIds,\n    uint256[] memory amounts,\n    bytes memory nftData\n  ) external {\n    require(msg.sender == owner, "only owner");\n    _mintBatch(account, nftIds, amounts, nftData);\n  }\n\n  /// @notice function to set the address of our NFT contracts on different chains.\n  /// This will help in access control when a cross-chain request is received.\n  /// @param chainId chain Id of the destination chain in string.\n  /// @param contractAddress address of the NFT contract on the destination chain.\n  function setContractOnChain(\n    string calldata chainId,\n    string calldata contractAddress\n  ) external {\n    require(msg.sender == owner, "only owner");\n    ourContractOnChains[chainId] = contractAddress;\n  }\n\n  /// @notice function to generate a cross-chain NFT transfer request.\n  /// @param destChainId chain ID of the destination chain in string.\n  /// @param transferParams transfer params struct.\n  /// @param requestMetadata abi-encoded metadata according to source and destination chains\n  function transferCrossChain(\n    string calldata destChainId,\n    TransferParams calldata transferParams,\n    bytes calldata requestMetadata\n  ) public payable {\n    require(\n      keccak256(abi.encodePacked(ourContractOnChains[destChainId])) !=\n        keccak256(abi.encodePacked("")),\n      "contract on dest not set"\n    );\n\n    // burning the NFTs from the address of the user calling _burnBatch function\n    _burnBatch(msg.sender, transferParams.nftIds, transferParams.nftAmounts);\n\n    // sending the transfer params struct to the destination chain as payload.\n    bytes memory packet = abi.encode(transferParams);\n    bytes memory requestPacket = abi.encode(\n      ourContractOnChains[destChainId],\n      packet\n    );\n\n    gatewayContract.iSend{ value: msg.value }(\n      1,\n      0,\n      string(""),\n      destChainId,\n      requestMetadata,\n      requestPacket\n    );\n  }\n\n  /// @notice function to get the request metadata to be used while initiating cross-chain request\n  /// @return requestMetadata abi-encoded metadata according to source and destination chains\n  function getRequestMetadata(\n    uint64 destGasLimit,\n    uint64 destGasPrice,\n    uint64 ackGasLimit,\n    uint64 ackGasPrice,\n    uint128 relayerFees,\n    uint8 ackType,\n    bool isReadCall,\n    bytes memory asmAddress\n  ) public pure returns (bytes memory) {\n    bytes memory requestMetadata = abi.encodePacked(\n      destGasLimit,\n      destGasPrice,\n      ackGasLimit,\n      ackGasPrice,\n      relayerFees,\n      ackType,\n      isReadCall,\n      asmAddress\n    );\n    return requestMetadata;\n  }\n\n  /// @notice function to handle the cross-chain request received from some other chain.\n  /// @param packet the payload sent by the source chain contract when the request was created.\n  /// @param srcChainId chain ID of the source chain in string.\n  function iReceive(\n    string memory,// requestSender,\n    bytes memory packet,\n    string memory srcChainId\n  ) external override returns (bytes memory) {\n    require(msg.sender == address(gatewayContract), "only gateway");\n    // decoding our payload\n    TransferParams memory transferParams = abi.decode(packet, (TransferParams));\n    _mintBatch(\n      toAddress(transferParams.recipient),\n      transferParams.nftIds,\n      transferParams.nftAmounts,\n      transferParams.nftData\n    );\n\n    return abi.encode(srcChainId);\n  }\n\n  /// @notice function to handle the acknowledgement received from the destination chain\n  /// back on the source chain.\n  /// @param requestIdentifier event nonce which is received when we create a cross-chain request\n  /// We can use it to keep a mapping of which nonces have been executed and which did not.\n  /// @param execFlag a boolean value suggesting whether the call was successfully\n  /// executed on the destination chain.\n  /// @param execData returning the data returned from the handleRequestFromSource\n  /// function of the destination chain.\n  function iAck(\n    uint256 requestIdentifier,\n    bool execFlag,\n    bytes memory execData\n  ) external override {}\n\n  /// @notice Function to convert bytes to address\n  /// @param _bytes bytes to be converted\n  /// @return addr address pertaining to the bytes\n  function toAddress(bytes memory _bytes) internal pure returns (address addr) {\n    bytes20 srcTokenAddress;\n    assembly {\n      srcTokenAddress := mload(add(_bytes, 0x20))\n    }\n    addr = address(srcTokenAddress);\n  }\n}\n')),(0,a.kt)("h2",{id:"step-2-cross-chain-functions-in-brief"},(0,a.kt)("strong",{parentName:"h2"},"STEP 2)")," Cross-Chain functions in brief"),(0,a.kt)("h3",{id:"1-transfercrosschain-function"},(0,a.kt)("strong",{parentName:"h3"},"1)")," transferCrossChain Function"),(0,a.kt)("p",null,"This function is responsible for creating a cross-chain NFT-transfer request. It first burns the NFT from contract on source chain, utilises gateway contracts' ",(0,a.kt)("inlineCode",{parentName:"p"},"ISend")," function to send request to mint the NFT to the user on the destination chain."),(0,a.kt)("h3",{id:"2-ireceive-function"},(0,a.kt)("strong",{parentName:"h3"},"2)")," IReceive Function"),(0,a.kt)("p",null,"Once a cross-chain request is initiated from the source chain, the message will be delivered to the destination chain which is received by ",(0,a.kt)("inlineCode",{parentName:"p"},"IReceive")," function that decodes the data and mints the NFT to the user."))}l.isMDXComponent=!0}}]);