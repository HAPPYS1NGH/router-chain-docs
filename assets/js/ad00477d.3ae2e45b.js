"use strict";(self.webpackChunkrouter_docs=self.webpackChunkrouter_docs||[]).push([[4653],{89804:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>i,metadata:()=>l,toc:()=>d});var n=a(87462),r=(a(67294),a(3905)),o=a(39164);const i={title:"Transfer of Reserve Tokens",sidebar_position:2},s=void 0,l={unversionedId:"voyager/understanding-voyager/transfer-reserve-token",id:"voyager/understanding-voyager/transfer-reserve-token",title:"Transfer of Reserve Tokens",description:"Reserve tokens are the tokens that have been kept in reserve by the Voyager protocol. The Voyager keeps reserves of some selected tokens on each chain so that it is able to provide fund transfers by locking funds on source chain and unlocking the funds on the destination chain. These include some stable tokens, wrapped native tokens for that chain as well as other tokens according to the needs as well as partnerships of projects with the Voyager .",source:"@site/docs/develop/voyager/understanding-voyager/transfer-reserve-token.md",sourceDirName:"voyager/understanding-voyager",slug:"/voyager/understanding-voyager/transfer-reserve-token",permalink:"/develop/voyager/understanding-voyager/transfer-reserve-token",draft:!1,editUrl:"https://github.com/router-protocol/docs/tree/main/docs/develop/voyager/understanding-voyager/transfer-reserve-token.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Transfer of Reserve Tokens",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Understanding different functions of Voyager",permalink:"/develop/voyager/understanding-voyager/understanding-different-functions"},next:{title:"Transfer of Reserve Tokens with Arbitrary Instruction",permalink:"/develop/voyager/understanding-voyager/transfer-reserve-token-arbitrary-instruction"}},c={},d=[],h={toc:d};function p(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},h,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"function depositReserveToken(\n        bool isSourceNative,\n        bytes calldata swapData,\n        bytes calldata executeData,\n        bytes calldata requestMetadata\n    ) external payable;\n")),(0,r.kt)("p",null,"Reserve tokens are the tokens that have been kept in reserve by the Voyager protocol. The Voyager keeps reserves of some selected tokens on each chain so that it is able to provide fund transfers by locking funds on source chain and unlocking the funds on the destination chain. These include some stable tokens, wrapped native tokens for that chain as well as other tokens according to the needs as well as partnerships of projects with the Voyager ."),(0,r.kt)("p",null,"When a user wants to transfer any of these reserve tokens from source chain to any other token on the destination chain, this function is to be called. After this function is called, the Voyager\u2019s infrastructure will handle the transfer of tokens to the other chain."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Parameters:")),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"isSourceNative"),(0,r.kt)("th",{parentName:"tr",align:null},"If the source token is the native token for that chain, this should be true."))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"swapData"),(0,r.kt)("td",{parentName:"tr",align:null},"abi encoded data for the required swap which is created by an API")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"executeData"),(0,r.kt)("td",{parentName:"tr",align:null},"abi encoded data for the execution on the destination chain which is created by an API")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},"requestMetadata"),(0,r.kt)("td",{parentName:"tr",align:null},"abi encoded data")))),(0,r.kt)("p",null,"The ",(0,r.kt)("strong",{parentName:"p"},"Swap Data")," includes:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"srcStableTokenAmount:")," Amount of the reserve token the user wants to transfer to the other chain."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"srcStableTokenAddress:")," Address of the reserve token the user wants to transfer to the other chain."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"srcTokenAddress:")," Address of the token the user wants to transfer to the other chain. This will be the same as srcStableTokenAddress in case of reserve tokens."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"destChainIdBytes:")," The Chain ID identifier for the destination chain.")),(0,r.kt)("p",null,"The ",(0,r.kt)("strong",{parentName:"p"},"Execute Data")," includes:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"destTokenAmount:")," Amount of destination tokens user will receive. This will be checked in the middleware and if this amount (USD Value) is larger than what user deposited, the transaction will be reverted."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"destTokenAddress:")," Address of the token user will receive on the destination chain."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"isDestNative:")," If the token to be received on the destination chain is native token for that chain, this is set to 1 else 0."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"destStableTokenAddress:")," Address of the stable token in which USD value for the tokens to be received will be calculated on the middleware."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"recipient:")," Address of the recipient on the destination chain."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"dataTx:")," Data for the transaction for swap on destination chain received from the API. If the token to be received on the destination chain is a reserve token or an LP token for that chain, the dataTx will be an empty bytes array."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"path:")," Path for the swap on destination chain received from the API. If the token to be received on the destination chain is a reserve token or an LP token for that chain, the path will be an empty address array."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"flags:")," The identifiers of DEXes that will be used for swap on destination chain received from the API. If the token to be received on the destination chain is a reserve token or an LP token for that chain, the flags will be an empty uint256 array."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"widgetID:")," Widget ID of the partner who has integrated the Voyager Widget. If you are not a partner, you can pass uint256 0 as widgetID.")),(0,r.kt)("admonition",{type:"info"},(0,r.kt)("p",{parentName:"admonition"},"Swap data and Execute data will directly be generated by the API. You don\u2019t need to worry about generating this data.")),(0,r.kt)("p",null,"The ",(0,r.kt)("strong",{parentName:"p"},"Request Metadata")," includes:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"destGasLimit:")," Gas limit required for execution of the request on the destination chain. This can be calculated using tools like ",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/hardhat-gas-reporter"},"hardhat-gas-reporter"),".")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"destGasPrice:")," Gas price of the destination chain. This can be calculated using the RPC of destination chain."))),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"// using ethers.js\nconst gasPrice = await provider.getGasPrice();\n\n// using web3.js\nconst gasPrice = web3.eth.getGasPrice().then((result) => {\n  console.log(web3.utils.fromWei(result, 'ether'));\n});\n")),(0,r.kt)("p",null,"To avoid the need for calculation, it can be passed as 0. The Router chain will then estimate the real-time gas price for them."),(0,r.kt)("ol",{start:3},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"ackGasLimit:")," Gas limit required for the execution of the acknowledgment on the source chain. This can be calculated using tools like ",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/hardhat-gas-reporter"},"hardhat-gas-reporter"),".")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"ackGasPrice:")," Gas price of the source chain. This can be calculated using the RPC of source chain as shown in the above snippet. To avoid the need for calculation, it can be passed as 0. The Router chain will then estimate the real-time gas price for them.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"relayerFees:")," This parameter functions similarly to the priority fees on other blockchain networks. Since the Router chain relayers handle the execution of cross-chain requests on the destination chain, setting a higher ",(0,r.kt)("inlineCode",{parentName:"p"},"relayerFees")," will increase the likelihood of your request being prioritized by relayers. If a very low ",(0,r.kt)("inlineCode",{parentName:"p"},"relayerFees")," is provided, the Router chain will automatically adjust it to the minimum required amount to ensure that it is executed. If it is passed as 0, the Router chain will default it to the minimum set Relayer fee value."))),(0,r.kt)("p",null,"Minimum relayer fees based on network is given below -"),(0,r.kt)(o.Z,{relayerApiData:[{apiUrl:"https://lcd.testnet.routerchain.dev/router-protocol/router-chain/crosschain/params",networkType:"Testnet"}],mdxType:"RelayerAPIData"}),(0,r.kt)("p",{style:{marginBottom:"30px"}}),(0,r.kt)("ol",{start:6},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"ackType:")," When the contract calls have been executed on the destination chain, the destination chain Gateway contract sends an acknowledgent back to the Router chain. iDapps have the option to get this acknowledgment from the Router chain to the source chain and execute some operations based on the ack.")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If ",(0,r.kt)("inlineCode",{parentName:"li"},"ackType")," = 0, the user doesn't want the acknowledgment to be forwarded back to the source chain."),(0,r.kt)("li",{parentName:"ul"},"If ",(0,r.kt)("inlineCode",{parentName:"li"},"ackType")," = 1, the acknowledgment is expected to be received only if the calls were successfully executed on the destination chain, and the user intends to perform some operation on the source chain after receiving the ack."),(0,r.kt)("li",{parentName:"ul"},"If ",(0,r.kt)("inlineCode",{parentName:"li"},"ackType")," = 2, an acknowledgment is needed only in case of an error occurring on the destination chain. This options also allows for execution of certain operations after receiving the ack."),(0,r.kt)("li",{parentName:"ul"},"If ",(0,r.kt)("inlineCode",{parentName:"li"},"ackType")," = 3, an acknowledgment is needed from the destination chain regardless of whether the call succeeds or fails, and some operations need to be performed based on the ack.")),(0,r.kt)("ol",{start:7},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"isReadCall:")," Router provides dApps an option to query a contract on another chain and receive the data back on the source chain as an acknowledgment. If the intention is only to query a contract on the destination chain and not perform any write operation there, then set this option to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),".")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"asmAddress:")," As part of Router's modular security framework, developers can integrate an ASM module to add an extra layer of security on top of the infra-level security provided by the Router Chain. These modules will be in the form of smart contracts on the destination chain, and their addresses should be passed as bytes in this variable. Documentation for ASM can be found ",(0,r.kt)("a",{parentName:"p",href:"/develop/message-transfer-via-crosstalk/key-concepts/additional-security-modules"},"here"),"."))),(0,r.kt)("p",null,"It can be achieved by adding the following function in your contract:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"function getRequestMetadata(\n    uint64 destGasLimit,\n    uint64 destGasPrice,\n    uint64 ackGasLimit,\n    uint64 ackGasPrice,\n    uint128 relayerFees,\n    uint8 ackType,\n    bool isReadCall,\n    bytes memory asmAddress\n    ) public pure returns (bytes memory) {\n    bytes memory requestMetadata = abi.encodePacked(\n        destGasLimit,\n        destGasPrice,\n        ackGasLimit,\n        ackGasPrice,\n        relayerFees,\n        ackType,\n        isReadCall,\n        asmAddress\n    );\n    return requestMetadata;\n    }\n")),(0,r.kt)("p",null,"Alternatively, the ",(0,r.kt)("inlineCode",{parentName:"p"},"requestMetadata")," parameter can be created in TypeScript or JavaScript using the following function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"function getRequestMetadata(\n  destGasLimit: number,\n  destGasPrice: number,\n  ackGasLimit: number,\n  ackGasPrice: number,\n  relayerFees: string,\n  ackType: number,\n  isReadCall: boolean,\n  asmAddress: string\n): string {\n  return ethers.utils.solidityPack(\n    [\n      'uint64',\n      'uint64',\n      'uint64',\n      'uint64',\n      'uint128',\n      'uint8',\n      'bool',\n      'string',\n    ],\n    [\n      destGasLimit,\n      destGasPrice,\n      ackGasLimit,\n      ackGasPrice,\n      relayerFees,\n      ackType,\n      isReadCall,\n      asmAddress,\n    ]\n  );\n}\n")))}p.isMDXComponent=!0},39164:(e,t,a)=>{a.d(t,{Z:()=>i});var n=a(67294),r=a(9669),o=a.n(r);const i=e=>{let{relayerApiData:t}=e;const[a,r]=(0,n.useState)([]);(0,n.useEffect)((()=>{i()}),[]);const i=async()=>{try{const e=t.map((e=>{let{apiUrl:t}=e;return o().get(t)})),a=await Promise.all(e),n=[];a.forEach(((e,a)=>{const{networkType:r}=t[a],o=s(e.data.params,r);n.push(...o)})),r(n)}catch(e){console.log(e)}},s=(e,t)=>{let a=[];return a=[{inboundGasPrice:e.inboundGasPrice,minimumRelayerFees:e.minimumRelayerFees/10**18,networkType:t}],a};return n.createElement("div",null,n.createElement("table",null,n.createElement("thead",null,n.createElement("tr",null,n.createElement("th",{style:{fontWeight:"bold"}},"Network Type"),n.createElement("th",{style:{fontWeight:"bold"}},"Min. Relayer Fees"))),n.createElement("tbody",null,a.map(((e,t)=>n.createElement("tr",{key:t},n.createElement("td",null,e.networkType),n.createElement("td",null,e.minimumRelayerFees," Route")))))))}}}]);