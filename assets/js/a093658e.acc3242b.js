"use strict";(self.webpackChunkrouter_docs=self.webpackChunkrouter_docs||[]).push([[5015],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>d});var n=r(67294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var l=n.createContext({}),c=function(e){var t=n.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},u=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},h=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),h=c(r),d=o,g=h["".concat(l,".").concat(d)]||h[d]||p[d]||a;return r?n.createElement(g,i(i({ref:t},u),{},{components:r})):n.createElement(g,i({ref:t},u))}));function d(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,i=new Array(a);i[0]=h;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var c=2;c<a;c++)i[c]=r[c];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}h.displayName="MDXCreateElement"},87137:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>i,default:()=>p,frontMatter:()=>a,metadata:()=>s,toc:()=>c});var n=r(87462),o=(r(67294),r(3905));const a={title:"Choosing the Right Cross-chain Framework",sidebar_position:2},i=void 0,s={unversionedId:"choosing-the-right-framework",id:"choosing-the-right-framework",title:"Choosing the Right Cross-chain Framework",description:"Router Protocol provides two ways using which developers can build cross-chain applications, namely -",source:"@site/docs/overview/choosing-the-right-framework.md",sourceDirName:".",slug:"/choosing-the-right-framework",permalink:"/overview/choosing-the-right-framework",draft:!1,editUrl:"https://github.com/router-protocol/docs/tree/main/docs/overview/choosing-the-right-framework.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Choosing the Right Cross-chain Framework",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/overview/"},next:{title:"Glossary",permalink:"/overview/glossary"}},l={},c=[{value:"CrossTalk Framework",id:"crosstalk-framework",level:3},{value:"Stateless",id:"stateless",level:4},{value:"Stateful",id:"stateful",level:4},{value:"Voyager",id:"voyager",level:3}],u={toc:c};function p(e){let{components:t,...r}=e;return(0,o.kt)("wrapper",(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Router Protocol provides two ways using which developers can build cross-chain applications, namely -"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"CrossTalk framework (stateless and stateful communication)"),(0,o.kt)("li",{parentName:"ol"},"Voyager (leveraging global liquidity with message transfers)")),(0,o.kt)("p",null,"Let us now understand which framework best suits your requirements before using it in your dApp. "),(0,o.kt)("h3",{id:"crosstalk-framework"},"CrossTalk Framework"),(0,o.kt)("h4",{id:"stateless"},"Stateless"),(0,o.kt)("p",null,"For standard cross-chain instruction transfers, CrossTalk framework is the best option. It is an easy-to-implement cross-chain smart contract library that can convert your existing multi-chain applications to cross-chain applications. CrossTalk's ability to transfer multiple contract-level instructions in a single cross-chain call makes it a very powerful tool. Various dApps like cross-chain NFTs (burning an NFT on one chain and minting it on another) and cross-chain lending/borrowing applications (enabling a borrower to provide collateral on one chain and then transferring an instruction to mint/unlock the borrower's desired token on the destination chain) can be built using this framework."),(0,o.kt)("h4",{id:"stateful"},"Stateful"),(0,o.kt)("p",null,"If an application does not require any logic in the middle or does not need any accounting layer, CrossTalk's generic workflow can be used. However, if you want to build an application that requires custom bridging logic or a decentralized accounting layer, you can use CrossTalk's stateful bridging. For example, you can use stateful bridging to create a multi-chain NFT collection with a single place to maintain the list of all the NFTs minted on different chains. If you wanted to use existing solutions, you'd have to maintain this list on all the chains where your dApp is deployed. In this case, by removing the redundancy involved in accounting, a CosmWasm contract on the Router chain act as a data aggregation layer. Another potential dApp that can benefit from Router's middleware capabilities is a cross-chain DEX. You'll need to deploy the token-swapping logic only on the Router chain, while smart contracts on other chains only need to include the locking/unlocking logic. "),(0,o.kt)("h3",{id:"voyager"},"Voyager"),(0,o.kt)("p",null,"Voyager is the native cross-chain asset-transfer bridge built on Router. It acts as the gateway to the liquidity managed by Router Protocol. Developers can use Voyager to access this liquidity and build either (a) other asset-transfer applications or (b) applications requiring both an asset transfer and an instruction transfer in a single sequenced cross-chain request. A very good example of the latter is a cross-chain yield aggregator that needs to transfer users' funds and an instruction to stake them in a particular contract, both in a single cross-chain request."))}p.isMDXComponent=!0}}]);