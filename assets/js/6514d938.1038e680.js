"use strict";(self.webpackChunkrouter_docs=self.webpackChunkrouter_docs||[]).push([[4792],{3905:(e,t,n)=>{n.d(t,{Zo:()=>h,kt:()=>p});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},h=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,h=s(e,["components","mdxType","originalType","parentName"]),u=l(n),p=r,m=u["".concat(c,".").concat(p)]||u[p]||d[p]||o;return n?a.createElement(m,i(i({ref:t},h),{},{components:n})):a.createElement(m,i({ref:t},h))}));function p(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var l=2;l<o;l++)i[l]=n[l];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},54953:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>d,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var a=n(87462),r=(n(67294),n(3905));const o={title:"Functions on third-party chain's contract",sidebar_position:3},i=void 0,s={unversionedId:"understanding-omnichain-framework/third-party-chain-contracts",id:"understanding-omnichain-framework/third-party-chain-contracts",title:"Functions on third-party chain's contract",description:"Router\u2019s Gateway contracts have a function named\xa0iSend that facilitates the transmission of a cross-chain request to the middleware contract on the Router Chain. Whenever users want to execute a cross-chain request, they can call this function by passing the payload to be transferred from the source to the Router chain.",source:"@site/docs/omnichain-framework/understanding-omnichain-framework/third-party-chain-contracts.md",sourceDirName:"understanding-omnichain-framework",slug:"/understanding-omnichain-framework/third-party-chain-contracts",permalink:"/omnichain-framework/understanding-omnichain-framework/third-party-chain-contracts",draft:!1,editUrl:"https://github.com/router-protocol/docs/tree/main/docs/omnichain-framework/understanding-omnichain-framework/third-party-chain-contracts.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Functions on third-party chain's contract",sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Understanding the Functions",permalink:"/omnichain-framework/understanding-omnichain-framework/understanding-functions"},next:{title:"Functions on Router chain's middleware contract",permalink:"/omnichain-framework/understanding-omnichain-framework/router-chain-middleware-contract/"}},c={},l=[{value:"iSend Function:",id:"isend-function",level:3},{value:"<strong>1. version:</strong>",id:"1-version",level:4},{value:"<strong>2. routeAmount:</strong>",id:"2-routeamount",level:4},{value:"<strong>3. routeRecipient:</strong>",id:"3-routerecipient",level:4},{value:"<strong>4. destChainId:</strong>",id:"4-destchainid",level:4},{value:"<strong>5. requestMetadata:</strong>",id:"5-requestmetadata",level:4},{value:"<strong>6. requestPacket:</strong>",id:"6-requestpacket",level:4},{value:"iReceive Function:",id:"ireceive-function",level:3}],h={toc:l};function d(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},h,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"Router\u2019s Gateway contracts have a function named\xa0",(0,r.kt)("inlineCode",{parentName:"p"},"iSend")," that facilitates the transmission of a cross-chain request to the middleware contract on the Router Chain. Whenever users want to execute a cross-chain request, they can call this function by passing the payload to be transferred from the source to the Router chain."),(0,r.kt)("p",null,"In addition to calling the aforementioned function, the recipient contract on the destination chain will also have to implement the function ",(0,r.kt)("inlineCode",{parentName:"p"},"iReceive")," to handle the requests received from the middleware contract."),(0,r.kt)("h3",{id:"isend-function"},"iSend Function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"function iSend(\n    uint256 version,\n    uint256 routeAmount,\n    string calldata routeRecipient,\n    string calldata destChainId,\n    bytes calldata requestMetadata,\n    bytes calldata requestPacket\n ) external payable returns (uint256);\n")),(0,r.kt)("p",null,"This is a function on the Router\u2019s Gateway contracts. This function creates a request to send a payload to the middleware contract on the Router Chain. By setting the parameters as per their requirements, users can use this function to exercise a wide range of functionalities when it comes to cross-chain message passing. These parameters include:"),(0,r.kt)("h4",{id:"1-version"},(0,r.kt)("strong",{parentName:"h4"},"1. version:")),(0,r.kt)("p",null,"Current version of Gateway contract which can be queried from the Gateway contract using the following function."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"function currentVersion() external view returns (uint256)\n")),(0,r.kt)("p",null,"This would change whenever the signature of iSend function or event ISendEvent will change. However the Router Chain will support earlier versions of encoding too for iDapps to always remain compatible."),(0,r.kt)("h4",{id:"2-routeamount"},(0,r.kt)("strong",{parentName:"h4"},"2. routeAmount:")),(0,r.kt)("p",null,"If one wants to transfer Route tokens along with the call, they will have to pass the amount of tokens to be transferred here."),(0,r.kt)("h4",{id:"3-routerecipient"},(0,r.kt)("strong",{parentName:"h4"},"3. routeRecipient:")),(0,r.kt)("p",null,"If one wants to transfer Route tokens along with the call, they will have to pass the address of recipient on the destination chain to which Route tokens will be minted on destination chain."),(0,r.kt)("h4",{id:"4-destchainid"},(0,r.kt)("strong",{parentName:"h4"},"4. destChainId:")),(0,r.kt)("p",null,"Chain ID of the destination chain in string format."),(0,r.kt)("h4",{id:"5-requestmetadata"},(0,r.kt)("strong",{parentName:"h4"},"5. requestMetadata:")),(0,r.kt)("p",null,"Some static information for the request. This is created so that iDapps don\u2019t have to encode it on-chain, they can just send it as a parameter to their iDapp depending on the destination chain Id passed by the user. The request metadata is a bytes encoded string consisting of the following parameters:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"uint64 destGasLimit;\nuint64 destGasPrice;\nuint64 ackGasLimit;\nuint64 ackGasPrice;\nuint128 relayerFees;\nuint8 ackType;\nbool isReadCall;\nstring asmAddress;\n")),(0,r.kt)("p",null,"It can be acheived by adding following function in your contract:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"function getRequestMetadata(\n    uint64 destGasLimit,\n    uint64 destGasPrice,\n    uint64 ackGasLimit,\n    uint64 ackGasPrice,\n    uint128 relayerFees,\n    uint8 ackType,\n    bool isReadCall,\n    bytes memory asmAddress\n    ) public pure returns (bytes memory) {\n    bytes memory requestMetadata = abi.encodePacked(\n        destGasLimit,\n        destGasPrice,\n        ackGasLimit,\n        ackGasPrice,\n        relayerFees,\n        ackType,\n        isReadCall,\n        asmAddress\n    );\n    return requestMetadata;\n    }\n")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"destGasLimit:")," Gas limit required for execution of the request on the destination chain. This can be calculated using tools like ",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/hardhat-gas-reporter"},"hardhat-gas-reporter"),".")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"destGasPrice:")," Gas price of the destination chain. This can be calculated using the RPC of destination chain."),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"// using ethers.js\nconst gasPrice = await provider.getGasPrice();\n\n// using web3.js\nconst gasPrice = web3.eth.getGasPrice().then((result) => {\n  console.log(web3.utils.fromWei(result, 'ether'));\n});\n")),(0,r.kt)("p",{parentName:"li"},"If you don\u2019t want to calculate it, just send ",(0,r.kt)("inlineCode",{parentName:"p"},"0")," in its place and Router Chain will handle the real time gas price for you.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"ackGasLimit:")," Gas limit required for execution of the acknowledgment coming from the destination chain back on the source chain. This can be calculated using tools like ",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/hardhat-gas-reporter"},"hardhat-gas-reporter"),".")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"ackGasPrice:")," Gas price of the destination chain. This can be calculated using the RPC of source chain as shown in the above ",(0,r.kt)("a",{parentName:"p",href:"https://www.notion.so/EVM-to-Other-Chain-Flow-de922b13e0fa4d7b8c3c24590ff8ef65"},"snippet"),".")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"relayerFees:")," This is similar to priority fees that one pays on other chains. Router chain relayers execute your requests on the destination chain. So if you want your request to be picked up by relayer faster, this should be set to a higher number. If you pass really low amount, the Router chain will adjust it to some minimum amount.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"ackType:")," When the contract calls have been executed on the destination chain, the iDapp has the option to get an acknowledgment back to the source chain."),(0,r.kt)("p",{parentName:"li"},"We provide the option to the user to be able to get this acknowledgment from the router chain to the source chain and perform some operation based on it."),(0,r.kt)("ol",{parentName:"li"},(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"ackType = 0:")," You don\u2019t want the acknowledgment to be forwarded back to the source chain."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"ackType = 1:")," You only want to receive the acknowledgment back to the source chain in case the calls executed successfully on the destination chain and perform some operation after that."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"ackType = 2:")," You only want to receive the acknowledgment back to the source chain in case the calls errored on the destination chain and perform some operation after that."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"ackType = 3:")," You only want to receive the acknowledgment back to the source chain in both the cases (success and error) and perform some operation after that."))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"isReadCall:")," We provide you the option to query a contract from another chain and get the data back on the source chain through acknowledgment. If you just want to query a contract on destination chain, set this to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),".")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"asmAddress:")," We also provide modular security framework for creating an additional layer of security on top of the security provided by Router Chain. These will be in the form of smart contracts on destination chain. The address of this contract needs to be passed in the form of bytes in this variable. Documentation for ASM can be found ",(0,r.kt)("a",{parentName:"p",href:"../../crosstalk/understanding-crosstalk/additionalSecurityModule.md"},"here")))),(0,r.kt)("h4",{id:"6-requestpacket"},(0,r.kt)("strong",{parentName:"h4"},"6. requestPacket:")),(0,r.kt)("p",null,"This is bytes encoded string consisting of two parameters:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"string destContractAddress\nbytes payload\n")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"destContractAddress:")," This is the address of the smart contract on the destination chain which will handle the payload that you send from the source chain to the destination chain.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"payload:")," This is bytes containing the payload that you want to send to the destination chain. This can be anything depending on your utility. For example, in case of NFT transfers, it can contain the NFT ID, the recipient address etc."),(0,r.kt)("p",{parentName:"li"},"This is the data that you will receive on the destination chain as packet. So you can pass any data or message that you want to pass to the destination chain."),(0,r.kt)("p",{parentName:"li"},"For transferring an NFT with some NFT ID and some recipient address, the request packet can be created using the following code:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'function getRequestPacket(\n      string calldata destinationContractAddress\n) external pure returns (bytes memory) {\n      // Here we are passing NFT ID and the recipient address as packet.\n      // However you can pass any other data as well.\n      bytes memory packet = abi.encode(<NFT_ID>, "RECIPIENT_ADDRESS");\n\n      return abi.encode(destinationContractAddress, packet);\n}\n')))),(0,r.kt)("p",null,"This function returns a nonce that serves as an identifier to your call to the Gateway contract. In this way, one can create a request to interact with the middleware contract on the Router Chain."),(0,r.kt)("h3",{id:"ireceive-function"},"iReceive Function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-jsx"},"function iReceive(\n    string memory requestSender,\n    bytes memory packet,\n    string memory srcChainId\n  ) external returns (bytes memory)\n")),(0,r.kt)("p",null,"This function needs to be implemented into the recipient smart contract on the destination chain. This function is responsible for handling the requests received from the middleware contract on the Router Chain."),(0,r.kt)("p",null,"This function should only be called by the Router\u2019s Gateway contract. Make sure to check that the msg sender is the Gateway contract address. Also, make sure that only your middleware contract can send the request by checking it with the address of the sender received in the parameters of the function"),(0,r.kt)("p",null,"In this function, you will get the address of the contract that initiated this request from the source chain, the payload you created on the source chain and the source chain ID. After receiving this information, you can process your payload and complete your cross-chain transaction."))}d.isMDXComponent=!0}}]);