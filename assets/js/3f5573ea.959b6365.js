"use strict";(self.webpackChunkrouter_docs=self.webpackChunkrouter_docs||[]).push([[3319],{3905:(e,t,a)=>{a.d(t,{Zo:()=>u,kt:()=>h});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function s(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?s(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):s(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function i(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},s=Object.keys(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var s=Object.getOwnPropertySymbols(e);for(n=0;n<s.length;n++)a=s[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var c=n.createContext({}),l=function(e){var t=n.useContext(c),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},u=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,s=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),p=l(a),h=r,m=p["".concat(c,".").concat(h)]||p[h]||d[h]||s;return a?n.createElement(m,o(o({ref:t},u),{},{components:a})):n.createElement(m,o({ref:t},u))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var s=a.length,o=new Array(s);o[0]=p;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:r,o[1]=i;for(var l=2;l<s;l++)o[l]=a[l];return n.createElement.apply(null,o)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},3908:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>s,metadata:()=>i,toc:()=>l});var n=a(87462),r=(a(67294),a(3905));const s={title:"request_to_dest",sidebar_position:1},o="request_to_dest Function",i={unversionedId:"understanding-crosstalk/near_guides/requestToDest",id:"understanding-crosstalk/near_guides/requestToDest",title:"request_to_dest",description:"By setting the parameters per their requirements, users can use this function to exercise a wide range of functionalities when it comes to cross-chain message passing. These parameters include:",source:"@site/docs/crosstalk/understanding-crosstalk/near_guides/requestToDest.md",sourceDirName:"understanding-crosstalk/near_guides",slug:"/understanding-crosstalk/near_guides/requestToDest",permalink:"/crosstalk/understanding-crosstalk/near_guides/requestToDest",draft:!1,editUrl:"https://github.com/router-protocol/docs/tree/main/docs/crosstalk/understanding-crosstalk/near_guides/requestToDest.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"request_to_dest",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Near Chain CrossTalk Functions",permalink:"/crosstalk/understanding-crosstalk/near_guides/"},next:{title:"handle_request_from_source",permalink:"/crosstalk/understanding-crosstalk/near_guides/handleRequestFromSource"}},c={},l=[{value:"1. request_args:",id:"1-request_args",level:3},{value:"2. ack_type:",id:"2-ack_type",level:3},{value:"3. ack_gas_params:",id:"3-ack_gas_params",level:3},{value:"4. destination_chain_params:",id:"4-destination_chain_params",level:3},{value:"5. contract_calls:",id:"5-contract_calls",level:3}],u={toc:l};function d(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},u,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"request_to_dest-function"},(0,r.kt)("inlineCode",{parentName:"h1"},"request_to_dest")," Function"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"#[payable]\npub fn request_to_dest(\n    &mut self,\n    request_args: RequestArgs,\n    ack_type: u8,\n    ack_gas_params: AckGasParams,\n    dest_chain_params: DestinationChainParams,\n    contract_calls: ContractCalls,\n) -> bool\n")),(0,r.kt)("p",null,"By setting the parameters per their requirements, users can use this function to exercise a wide range of functionalities when it comes to cross-chain message passing. These parameters include:"),(0,r.kt)("h3",{id:"1-request_args"},"1. request_args:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"exp_timestamp:")," If you want to add a specific expiry timestamp, you can mention it against this parameter. Your request will get reverted if it is not executed before the expiryTimestamp."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"is_atomic_calls:")," Set it to true if you want to ensure that either all your contract calls are executed or none of them are executed. Set it to false if you do not require atomicity.")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If this variable is set to ",(0,r.kt)("strong",{parentName:"li"},"true"),", either all the contract calls will be executed on the destination chain or none of them will be executed."),(0,r.kt)("li",{parentName:"ul"},"If this variable is set to ",(0,r.kt)("strong",{parentName:"li"},"false"),", even if some of the contracts calls fail on the destination chain, other calls won't be affected.")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct RequestArgs {\n    pub exp_timestamp: u64,\n    pub is_atomic_calls: bool,\n}\n")),(0,r.kt)("h3",{id:"2-ack_type"},"2. ack_type:"),(0,r.kt)("p",null,"When the contract calls are executed on the destination chain, the Router chain receives an acknowledgment from the destination chain, which specifies whether the execution was successful or did it result in some error. We provide users the option to get this acknowledgment from the Router chain to the source chain and perform some operations based on that acknowledgment."),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"ack_type = 0:")," You don't want to receive the acknowledgment on the source chain."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"ack_type = 1:")," You only want to receive the acknowledgment on the source chain if the calls are executed successfully on the destination chain."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"ack_type = 2:")," You only want to receive the acknowledgment on the source chain in case the calls failed on the destination chain."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"ack_type = 3:")," You want to receive the acknowledgment on the source chain in both cases (success and error).")),(0,r.kt)("h3",{id:"3-ack_gas_params"},"3. ack_gas_params:"),(0,r.kt)("p",null,"If you opted to receive the acknowledgment on the source chain, you would need to write a callback function (discussed ",(0,r.kt)("a",{parentName:"p",href:"/crosstalk/understanding-crosstalk/near_guides/handleCrossTalkAck"},"here"),") to handle the acknowledgment. The ack_gas_params parameter includes the gas limit and gas price required to execute the callback function on the source chain when the acknowledgment is received. The gas limit depends on the complexity of the callback function, and the gas price depends on the source chain congestion."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-rust"},"pub struct AckGasParams {\n    pub gas_limit: u64,\n    pub gas_price: u64,\n}\n")),(0,r.kt)("p",null,"If the user does not want to handle the acknowledgment, i.e., the ackType is ",(0,r.kt)("strong",{parentName:"p"},"0"),", then the gas limit and gas price for ack_gas_params should be zero."),(0,r.kt)("h3",{id:"4-destination_chain_params"},"4. destination_chain_params:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"pub struct DestinationChainParams {\n    pub gas_limit: u64,\n    pub gas_price: u64,\n    pub dest_chain_type: u64,\n    pub dest_chain_id: String,\n    pub asm_address: Vec<u8>,\n}\n")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"gas_limit:")," Gas limit required to execute the cross-chain request on the destination chain."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"gas_price:")," Gas price to be passed on the destination chain."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"dest_chain_type:")," This represents the type of chain. The values for chain types can be found ",(0,r.kt)("a",{parentName:"li",href:"/crosstalk/understanding-crosstalk/chainTypes"},"here"),"."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"dest_chain_id:")," Chain ID of the destination chain in string format."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"asm_address:")," Address of Additional Security Module (ASM) contract that acts as a plugin which enables users to seamlessly integrate their own security mechanism into their DApp.")),(0,r.kt)("h3",{id:"5-contract_calls"},"5. contract_calls:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},"pub struct ContractCalls {\n    pub payloads: Vec<Vec<u8>>,\n    pub dest_contract_addresses: Vec<Vec<u8>>,\n}\n")),(0,r.kt)("p",null,"The contract_calls parameter includes an array of payloads and contract addresses to be sent to the destination chain. All the payloads will be sent to the respective contract addresses as specified in the arrays. The payload can include anything, i.e. you can pass whatever you want in this payload from the source chain and handle that payload on the destination chain."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Note:")," We would suggest passing the payload as abi encoded value so that it is easier to decode in all environments.")),(0,r.kt)("p",null,"Please use the following format for passing the destination contract addresses:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"For EVM chains as the destination chain:")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"fn convert_evm_address_to_vec(evm_address: String) -> Vec<u8> {\n  let addr = evm_address.split_at(2).1;\n  let addr_as_vec = hex::decode(addr);\n\n  addr_as_vec.unwrap()\n}\n\n")))}d.isMDXComponent=!0}}]);