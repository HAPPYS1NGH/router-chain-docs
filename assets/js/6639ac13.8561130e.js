"use strict";(self.webpackChunkrouter_docs=self.webpackChunkrouter_docs||[]).push([[2921],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>p});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,c=e.parentName,d=i(e,["components","mdxType","originalType","parentName"]),u=l(n),p=r,f=u["".concat(c,".").concat(p)]||u[p]||h[p]||o;return n?a.createElement(f,s(s({ref:t},d),{},{components:n})):a.createElement(f,s({ref:t},d))}));function p(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,s=new Array(o);s[0]=u;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:r,s[1]=i;for(var l=2;l<o;l++)s[l]=n[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},10226:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var a=n(87462),r=(n(67294),n(3905));const o={title:"Sequenced Transfers (tokens + instructions) using Voyager",sidebar_position:2},s=void 0,i={unversionedId:"building-different-use-cases/sequenced-transfers",id:"building-different-use-cases/sequenced-transfers",title:"Sequenced Transfers (tokens + instructions) using Voyager",description:"As we discussed in the previous section, the Voyager allows us to transfer tokens as well as sequence token transfers and arbitrary instructions. In this section, we will explore how you can integrate the Voyager into your smart contracts for sequencing cross-chain token transfers and arbitrary instructions.",source:"@site/docs/voyager/building-different-use-cases/sequenced-transfers.md",sourceDirName:"building-different-use-cases",slug:"/building-different-use-cases/sequenced-transfers",permalink:"/voyager/building-different-use-cases/sequenced-transfers",draft:!1,editUrl:"https://github.com/router-protocol/docs/tree/main/docs/voyager/building-different-use-cases/sequenced-transfers.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Sequenced Transfers (tokens + instructions) using Voyager",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Token Transfer using Voyager Contracts",permalink:"/voyager/building-different-use-cases/token-transfers"},next:{title:"Voyager Tools",permalink:"/voyager/tools/"}},c={},l=[{value:"Getting the data for the token transfer",id:"getting-the-data-for-the-token-transfer",level:3},{value:"Creating the data for the arbitrary instruction",id:"creating-the-data-for-the-arbitrary-instruction",level:3},{value:"Calling the Voyager Deposit function",id:"calling-the-voyager-deposit-function",level:3},{value:"Handling the request on the destination chain contract",id:"handling-the-request-on-the-destination-chain-contract",level:3}],d={toc:l};function h(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"As we discussed in the previous section, the Voyager allows us to transfer tokens as well as sequence token transfers and arbitrary instructions. In this section, we will explore how you can integrate the Voyager into your smart contracts for sequencing cross-chain token transfers and arbitrary instructions."),(0,r.kt)("p",null,"The functions that can be called on the Voyager for cross-chain sequencing are:"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"depositReseveTokenAndExecute"),(0,r.kt)("li",{parentName:"ol"},"depositLPTokenAndExecute"),(0,r.kt)("li",{parentName:"ol"},"depositNonReserveTokenAndExecute")),(0,r.kt)("p",null,"While you can definitely integrate only one of these functionalities into your contracts according to your needs, we suggest you to use the call with selector method to be able to call any of these functions from your contracts."),(0,r.kt)("h3",{id:"getting-the-data-for-the-token-transfer"},"Getting the data for the token transfer"),(0,r.kt)("p",null,"We will provide an API for the developers which will provide you the calldata for the swap directly. You won\u2019t need to do anything, just call the API, get the data and call the Voyager using that data for token transfers. For the arbitrary instructions, we will demonstrate how you can create the arbitrary data too in this section."),(0,r.kt)("p",null,"The params for the API call to get data for the swap are: "),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"fromTokenAddress:")," Address of the token to be transferred from the source chain."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"toTokenAddress:")," Address of the token to be received on the destination chain."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"fromChainId:")," Chain ID of the source chain."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"fromChainType:")," Chain type of source chain."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"toTokenChainId:")," Chain ID of the destination chain."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"toChainType:")," Chain type of destination chain."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"isDestNative:")," Whether the required token on the destination chain is the native token for that chain."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"recipientAddress:")," Address of the recipient."),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("strong",{parentName:"li"},"isOnlyTokenTransfer:")," This is a boolean value indicating whether the goal is token transfer only. In this case, since we don\u2019t just want token transfers but the sequencing also, we will send false in its place.")),(0,r.kt)("p",null,"The data received from the API response will give you the function selector for deposit function that needs to be called on the Voyager Deposit Handler and the data pertaining to the swap."),(0,r.kt)("h3",{id:"creating-the-data-for-the-arbitrary-instruction"},"Creating the data for the arbitrary instruction"),(0,r.kt)("p",null,"Arbitrary instructions are custom pieces of code which are executed on the destination chain after the token transfer is complete. The arbitrary data needs to be sent along with the token transfers on the source chain. This data is sent as it is to the destination chain without tampering with it. You can handle the execution of this data on your contract on the destination chain."),(0,r.kt)("p",null,"Let\u2019s start with a simple token transfer and stake functionality where user will call a function which will transfer the tokens to another chain and then call the stake function to stake the tokens received into the contract."),(0,r.kt)("p",null,"Let\u2019s say you want to create a function to transfer your funds and then stake it on another chain, then you will need to create a function to create that request on the source chain and a function to handle that request on the destination chain. "),(0,r.kt)("p",null,"Let\u2019s create a function to create that request on the source chain. For the details regarding the Arbitrary Data that needs to be generated, please check ",(0,r.kt)("a",{parentName:"p",href:"../understanding-voyager/transfer-reserve-token-arbitrary-instruction#arbitrary-data"},"this"),"."),(0,r.kt)("p",null,"The arbitrary data consists of six fields: "),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Destination contract address which will handle the request."),(0,r.kt)("li",{parentName:"ol"},"The selector to the function which has the logic for handling the request."),(0,r.kt)("li",{parentName:"ol"},"The data which contains the parameters for the function for which selector was passed. Note that this data won\u2019t contain information regarding the token that will be received or the amount of tokens that will be received on the destination chain since this can vary in some cases depending on the fee and liquidity conditions."),(0,r.kt)("li",{parentName:"ol"},"The address which will get the gas refund if there is some gas left after the execution."),(0,r.kt)("li",{parentName:"ol"},"The gas limit that needs to be used while executing the call on the destination chain.."),(0,r.kt)("li",{parentName:"ol"},"The gas price that needs to be used while executing the call on the destination chain.")),(0,r.kt)("p",null,"Let\u2019s consider that the handler function for the call on the destination chain is a stake function which looks like:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"function stake(address user, address token, uint256 amount) internal\n")),(0,r.kt)("p",null,"Then the selector that needs to be passed can be generated easily. So we generate the selector to the function and store it in the ",(0,r.kt)("strong",{parentName:"p"},"STAKE_FUNCTION_SELECTOR")," variable. We take the address of the recipient in whose address the stake will be registered, the refund address, the gas limit and the gas price for the destination chain in the parameters and return the arbitrary data."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'address public destContractAddress;\n// function stake(address user, address token, uint256 amount);\nbytes4 public constant STAKE_FUNCTION_SELECTOR = bytes4(keccak256("stake(address,address,uint256)"));\n\nfunction createDataForStaking(\n    address recipient,\n    address refundAddress,\n    uint256 gasLimit,\n    uint256 gasPrice\n) public returns (bytes memory) {\n    bytes memory data = abi.encode(recipient);\n\n    return abi.encode(\n        destContractAddress, \n        STAKE_FUNCTION_SELECTOR, \n        data, \n        refundAddress, \n        gasLimit, \n        gasPrice\n    );\n}\n')),(0,r.kt)("p",null,"This gives us the arbitrary data which can be used to call the functions of the Deposit Handler. "),(0,r.kt)("h3",{id:"calling-the-voyager-deposit-function"},"Calling the Voyager Deposit function"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'address public voyagerDepositHandler = "address of voyager deposit handler";\n// depositReserveTokenAndExecute(bool,bytes,bytes,bytes)\nbytes4 public constant DEPOSIT_RESERVE_AND_EXECUTE_SELECTOR = 0x2dc2ab1d;\n// depositNonReserveTokenAndExecute(bool,bytes,bytes,bytes)\nbytes4 public constant DEPOSIT_NON_RESERVE_AND_EXECUTE_SELECTOR = 0x2c191edd;\n// depositLPTokenAndExecute(bytes,bytes,bytes)\nbytes4 public constant DEPOSIT_LP_AND_EXECUTE_SELECTOR = 0x1c117a77;\n\nfunction callVoyager(\n    bytes4 depositFunctionSelector, \n    bytes calldata dataForTokenTransfer, \n    bytes memory arbitraryData\n) public \n{\n    bool success;\n    bytes memory data;\n    if(\n        depositFunctionSelector == DEPOSIT_RESERVE_AND_EXECUTE_SELECTOR ||\n        depositFunctionSelector == DEPOSIT_NON_RESERVE_AND_EXECUTE_SELECTOR \n    ) {\n        (bool isSourceNative, bytes memory swapData, bytes memory executeData) \n                = abi.decode(data, (bool, bytes, bytes));\n        (success, data) = voyagerDepositHandler.call(\n                abi.encodeWithSelector(\n                    depositFunctionSelector, \n                    isSourceNative, \n                    swapData, \n                    executeData,\n                    arbitraryData\n                )\n        );\n    } else if(depositFunctionSelector == DEPOSIT_LP_AND_EXECUTE_SELECTOR ) {\n        (bytes memory swapData, bytes memory executeData) \n                = abi.decode(data, (bytes, bytes));\n        (success, data) = voyagerDepositHandler.call(\n                abi.encodeWithSelector(\n                    DEPOSIT_LP_AND_EXECUTE_SELECTOR, \n                    swapData, \n                    executeData,\n                    arbitraryData\n                )\n         );\n    \n    }\n\n    require(success == true, "Voyager deposit failed");\n} \n')),(0,r.kt)("h3",{id:"handling-the-request-on-the-destination-chain-contract"},"Handling the request on the destination chain contract"),(0,r.kt)("p",null,"The entry point of the cross-chain request for arbitrary instructions is the ",(0,r.kt)("strong",{parentName:"p"},"voyagerReceive"),"  function which needs to be implemented on each contract that wants to handle an arbitrary instruction from the Voyager. The detailed explanation for this function can be found ",(0,r.kt)("a",{parentName:"p",href:"../understanding-voyager/transfer-reserve-token-arbitrary-instruction#voyagerreceive"},"here"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"function voyagerReceive(\n    address sourceSenderAddress, \n    bytes32 srcChainIdBytes, \n    bytes4 selector, \n    bytes memory data, \n    address settlementToken, \n    uint256 settlementAmount\n) external; \n")),(0,r.kt)("p",null,"This function is called by the Voyager Execute Handler, so make sure that only the Execute Handler can call this contract by using access control or a modifier otherwise the contract can be potentially exploited. Similarly also put a check on the source sender addresses so that only your contracts on different chains can call this function."),(0,r.kt)("p",null,"The function receives the following parameters: "),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"The address of the contract which initiated the request on the source chain. "),(0,r.kt)("li",{parentName:"ol"},"The identifier for the source chain."),(0,r.kt)("li",{parentName:"ol"},"The selector to the function passed to the contract from the source chain."),(0,r.kt)("li",{parentName:"ol"},"The data variable sent from the source chain."),(0,r.kt)("li",{parentName:"ol"},"The address of the token received by the recipient on the destination chain."),(0,r.kt)("li",{parentName:"ol"},"The amount of tokens received by the recipient on destination chain.")),(0,r.kt)("p",null,"Let\u2019s implement a function on the destination chain to handle the request coming from another chain."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'address sourceContractAddress;\naddress voyagerExecuteHandler;\n// user address + token address => amount staked\nmapping(address => mapping(address => uint256)) stakedBalance;\n\nfunction voyagerReceive(\n    address sourceSenderAddress,\n    bytes32 srcChainIdBytes,\n    bytes4 selector,\n    bytes memory data,\n    address settlementToken,\n    uint256 settlementAmount\n) external {\n        // Checking if the sender is the voyager execute handler contract\n    require(msg.sender == voyagerExecuteHandler, "only voyager execute handler");\n        // Checking if the request initiated by our contract only from the source chain\n    require(\n            sourceContractAddress == sourceSenderAddress, \n            "source sender does not match"\n        );\n        \n    // Checking the selector that was passed from the source chain\n    if (selector == stake.selector) {\n        // decoding the data we sent from the source chain\n        address user = abi.decode(data, (address));\n        // calling the stake function\n        stake(user, settlementToken, settlementAmount);\n    }\n}\n\n// The handler function for the stake request\nfunction stake(\n    address user,\n    address token,\n    address amount\n) internal {\n    // Updating the staked balances mapping \n    stakedBalance[user][token] += amount;\n}\n')),(0,r.kt)("p",null,"In this way, you can handle cross-chain requests from the Voyager on the destination chain."))}h.isMDXComponent=!0}}]);