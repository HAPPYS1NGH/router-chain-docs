"use strict";(self.webpackChunkrouter_docs=self.webpackChunkrouter_docs||[]).push([[7713],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>p});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var c=r.createContext({}),d=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},u=function(e){var t=d(e.components);return r.createElement(c.Provider,{value:t},e.children)},l={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},m=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),m=d(n),p=a,h=m["".concat(c,".").concat(p)]||m[p]||l[p]||o;return n?r.createElement(h,i(i({ref:t},u),{},{components:n})):r.createElement(h,i({ref:t},u))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,i=new Array(o);i[0]=m;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var d=2;d<o;d++)i[d]=n[d];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}m.displayName="MDXCreateElement"},87572:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>l,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var r=n(87462),a=(n(67294),n(3905));const o={title:"RouterMsg",sidebar_position:2},i=void 0,s={unversionedId:"understanding-omnichain-framework/router-chain-middleware-contract/routermsg",id:"understanding-omnichain-framework/router-chain-middleware-contract/routermsg",title:"RouterMsg",description:"The RouterMsg is an enum type inside the router-wasm-bindings. It contains one custom message type.",source:"@site/docs/omnichain-framework/understanding-omnichain-framework/router-chain-middleware-contract/routermsg.md",sourceDirName:"understanding-omnichain-framework/router-chain-middleware-contract",slug:"/understanding-omnichain-framework/router-chain-middleware-contract/routermsg",permalink:"/omnichain-framework/understanding-omnichain-framework/router-chain-middleware-contract/routermsg",draft:!1,editUrl:"https://github.com/router-protocol/docs/tree/main/docs/omnichain-framework/understanding-omnichain-framework/router-chain-middleware-contract/routermsg.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"RouterMsg",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"SudoMsg",permalink:"/omnichain-framework/understanding-omnichain-framework/router-chain-middleware-contract/sudomsg"},next:{title:"Sample Contracts",permalink:"/omnichain-framework/understanding-omnichain-framework/sample-contracts"}},c={},d=[],u={toc:d};function l(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"RouterMsg")," is an enum type inside the ",(0,a.kt)("em",{parentName:"p"},"router-wasm-bindings"),". It contains one custom message type."),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"CrosschainCall")),(0,a.kt)("p",null,"In the following code snippet, we have added one implementation of CrosschainCall. This message is used to create an outbound request. In the outbound request, we can specify the destination chain id & type, the contract addresses & instructions, the request expiry timestamp, the atomicity flag, etc."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-jsx"},"// import router binding message\nuse router_wasm_bindings::{RouterMsg, SudoMsg};\nuse router_wasm_bindings::types::{\n    AckType, RequestMetaData,\n};\nuse cosmwasm_std::{SubMsg, SubMsgResult, Uint128};\n\nlet request_packet: Bytes = encode(&[\n    Token::String(destination_address.clone()),\n    Token::Bytes(payload),\n]);\nlet request_metadata: RequestMetaData = RequestMetaData {\n    dest_gas_limit: gas_limit,\n    dest_gas_price: gas_price,\n    ack_gas_limit: 300_000,\n    ack_gas_price: 10_000_000,\n    relayer_fee: Uint128::zero(),\n    ack_type: AckType::AckOnBoth,\n    is_read_call: false,\n    asm_address: String::default(),\n};\n\nlet i_send_request: RouterMsg = RouterMsg::CrosschainCall {\n    version: 1,\n    route_amount,\n    route_recipient,\n    dest_chain_id: destination_chain_id,\n    request_metadata: request_metadata.get_abi_encoded_bytes(),\n    request_packet,\n};\n\nlet cross_chain_sub_msg: SubMsg<RouterMsg> = SubMsg {\n    id: CREATE_OUTBOUND_REPLY_ID,\n    msg: i_send_request.into(),\n    gas_limit: None,\n    reply_on: ReplyOn::Success,\n};\nlet res = Response::new()\n    .add_submessage(cross_chain_sub_msg.into())\nOk(res)\n")),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"CrosschainCall")," is a data_type that helps the end user to create an cross-chain request to any destination chain. It has 6 arguments."),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"version:")," The chain type of the chain for which the outbound request from the Router chain has been created."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"route_amount:")," The route token amount that needs to be burned on the router chain and minted/unlocked on the destination chain."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"route_recipient:")," The recipient address of the route token on the destination chain."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"destination_chain_id:")," The chain ID of the chain for which the outbound request from the Router chain has been created."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"request_metadata:")," The request metadata is encodedPacked information that contains information destination gas limit & price, ack gas limit & price, relayer fee, ack_type, is_read_call and asm_address."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"request_packet:")," The request packet is encoded information of destination address and payload. In example we can see how are we encoding this information.")),(0,a.kt)("p",null,"Since the application developer is writing the application middleware contracts, they will have complete control over what kind of data is received in the payload. They can define the encoding and decoding of the data accordingly and perform any operation on the data."))}l.isMDXComponent=!0}}]);