"use strict";(self.webpackChunkrouter_docs=self.webpackChunkrouter_docs||[]).push([[6283],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>d});var o=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);t&&(o=o.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,o)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function l(e,t){if(null==e)return{};var n,o,r=function(e,t){if(null==e)return{};var n,o,r={},a=Object.keys(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(o=0;o<a.length;o++)n=a[o],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=o.createContext({}),s=function(e){var t=o.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=s(e.components);return o.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return o.createElement(o.Fragment,{},t)}},h=o.forwardRef((function(e,t){var n=e.components,r=e.mdxType,a=e.originalType,c=e.parentName,p=l(e,["components","mdxType","originalType","parentName"]),h=s(n),d=r,m=h["".concat(c,".").concat(d)]||h[d]||u[d]||a;return n?o.createElement(m,i(i({ref:t},p),{},{components:n})):o.createElement(m,i({ref:t},p))}));function d(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var a=n.length,i=new Array(a);i[0]=h;var l={};for(var c in t)hasOwnProperty.call(t,c)&&(l[c]=t[c]);l.originalType=e,l.mdxType="string"==typeof e?e:r,i[1]=l;for(var s=2;s<a;s++)i[s]=n[s];return o.createElement.apply(null,i)}return o.createElement.apply(null,n)}h.displayName="MDXCreateElement"},18657:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>a,metadata:()=>l,toc:()=>s});var o=n(87462),r=(n(67294),n(3905));const a={title:"Overview",sidebar_position:1},i=void 0,l={unversionedId:"overview",id:"overview",title:"Overview",description:"Motivation",source:"@site/docs/omnichain-framework/overview.md",sourceDirName:".",slug:"/overview",permalink:"/omnichain-framework/overview",draft:!1,editUrl:"https://github.com/router-protocol/docs/tree/main/docs/omnichain-framework/overview.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"Overview",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/omnichain-framework/"},next:{title:"High-level Workflow",permalink:"/omnichain-framework/high-level-workflow"}},c={},s=[{value:"Motivation",id:"motivation",level:2},{value:"About OmniChain",id:"about-omnichain",level:2},{value:"High-level Workflow",id:"high-level-workflow",level:2},{value:"Inbound Workflow",id:"inbound-workflow",level:3},{value:"Outbound Workflow",id:"outbound-workflow",level:3}],p={toc:s};function u(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,o.Z)({},p,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h2",{id:"motivation"},"Motivation"),(0,r.kt)("p",null,"Even though a number of cross-chain message transfer frameworks have come to fore in the last couple of years, there have been none that offer the ability for the developers to incorporate custom bridging logic within their cross-chain dApp. Although most cross-chain applications can work well with a generic message transfer approach, there are a few that need a solution that affords them greater level of control over their dApps. "),(0,r.kt)("h2",{id:"about-omnichain"},"About OmniChain"),(0,r.kt)("p",null,"Router's OmniChain framework leverages Router chain's architectural components to allow developers to create seamless cross-chain applications with custom bridging logic. It even allows them to deploy their application-specific security layer on top of the infra-level security layer provided by Router. By allowing developers to program their logic on just one smart contract on the Router chain, Router's OmniChain framework will reduce code redundancy and save developers' time and effort."),(0,r.kt)("h2",{id:"high-level-workflow"},"High-level Workflow"),(0,r.kt)("center",null,(0,r.kt)("img",{src:n(92841).Z,alt:"High Level Workflow"})),(0,r.kt)("p",null,"Any cross-chain request between two third-party chains is divided into two independent flows - ",(0,r.kt)("strong",{parentName:"p"},"Inbound")," and ",(0,r.kt)("strong",{parentName:"p"},"Outbound"),"."),(0,r.kt)("blockquote",null,(0,r.kt)("p",{parentName:"blockquote"},(0,r.kt)("strong",{parentName:"p"},"Warning:")," Not all inbound requests need to have a corresponding outbound request, and vice versa. In any cross-chain request with the Router chain as the destination chain, there won't be any outbound request. Similarly, any cross-chain request originating from the Router chain won't have any inbound request. ")),(0,r.kt)("h3",{id:"inbound-workflow"},"Inbound Workflow"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step 1)")," A user initiates a cross-chain action on an application's smart contract on the source chain."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step 2)")," The application contract then calls the ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"RequestToRouter()"))," function on the Router Gateway contract with the relevant parameters."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step 3)")," The Gateway contract on the source chain emits an event that is listened to by the orchestrators on the Router chain."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step 4)")," After validating the event with the help of the attestation module, the inbound module passes the event to the application's bridge contract on the Router chain, where it can implement its custom business logic."),(0,r.kt)("h3",{id:"outbound-workflow"},"Outbound Workflow"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step 1)")," After the transaction initiated by the bridge contract is mined on the Router chain, the outbound module picks up the outbound request generated by the bridge contract."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step 2)")," The outbound module collects and persists all the signatures given by orchestrators to validate the outbound request."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step 3)")," Once the majority voting power is achieved, the relayer polling the outbound requests of that particular bridge contract picks up the transaction and forwards the event to the Router Gateway contract on the destination chain."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step 4)")," The Gateway contract on the destination chain calls the ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"handleRequestFromRouter()"))," function on the application contract on the destination chain."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step 5)")," The application contract on the destination chain will take appropriate actions based on the data transferred."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"Step 6)")," After the ",(0,r.kt)("strong",{parentName:"p"},(0,r.kt)("inlineCode",{parentName:"strong"},"handleRequestFromRouter()"))," function execution is complete on the destination chain, the destination chain's Gateway contract emits an acknowledgment event that is listened to by the orchestrators on the Router chain."))}u.isMDXComponent=!0},92841:(e,t,n)=>{n.d(t,{Z:()=>o});const o=n.p+"assets/images/high-level-workflow-ca0164db81fe3f910ffe3b994d82a048.png"}}]);