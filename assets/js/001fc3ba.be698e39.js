"use strict";(self.webpackChunkrouter_docs=self.webpackChunkrouter_docs||[]).push([[7316],{3905:(e,t,r)=>{r.d(t,{Zo:()=>d,kt:()=>h});var n=r(67294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var c=n.createContext({}),l=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},d=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=l(r),h=a,f=p["".concat(c,".").concat(h)]||p[h]||u[h]||o;return r?n.createElement(f,i(i({ref:t},d),{},{components:r})):n.createElement(f,i({ref:t},d))}));function h(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=p;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var l=2;l<o;l++)i[l]=r[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}p.displayName="MDXCreateElement"},26655:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var n=r(87462),a=(r(67294),r(3905));const o={title:"Transfer of Reserve Tokens with Arbitrary Instruction",sidebar_position:3},i=void 0,s={unversionedId:"voyager/understanding-voyager/transfer-reserve-token-arbitrary-instruction",id:"voyager/understanding-voyager/transfer-reserve-token-arbitrary-instruction",title:"Transfer of Reserve Tokens with Arbitrary Instruction",description:"The flow is just the same as that of the reserve token transfer explained before. The only difference here is the arbitrary data that you need to pass and state whether the tokens that need to be swapped are to be deducted from the user or the application.",source:"@site/docs/develop/voyager/understanding-voyager/transfer-reserve-token-arbitrary-instruction.md",sourceDirName:"voyager/understanding-voyager",slug:"/voyager/understanding-voyager/transfer-reserve-token-arbitrary-instruction",permalink:"/develop/voyager/understanding-voyager/transfer-reserve-token-arbitrary-instruction",draft:!1,editUrl:"https://github.com/router-protocol/docs/tree/main/docs/develop/voyager/understanding-voyager/transfer-reserve-token-arbitrary-instruction.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Transfer of Reserve Tokens with Arbitrary Instruction",sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Transfer of Reserve Tokens",permalink:"/develop/voyager/understanding-voyager/transfer-reserve-token"},next:{title:"Transfer of Non-Reserve Tokens",permalink:"/develop/voyager/understanding-voyager/transfer-non-reserve-token"}},c={},l=[{value:"Arbitrary Data",id:"arbitrary-data",level:3},{value:"<code>voyagerReceive</code>",id:"voyagerreceive",level:3}],d={toc:l};function u(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,n.Z)({},d,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"function depositReserveTokenAndExecute(\n        bool isSourceNative,\n        bool isAppTokenPayer,\n        bytes calldata swapData,\n        bytes calldata executeData,\n        bytes calldata arbitraryData,\n        bytes calldata requestMetadata\n    ) external payable;\n")),(0,a.kt)("p",null,"The flow is just the same as that of the reserve token transfer explained before. The only difference here is the arbitrary data that you need to pass and state whether the tokens that need to be swapped are to be deducted from the user or the application."),(0,a.kt)("h3",{id:"arbitrary-data"},"Arbitrary Data"),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Arbitrary Data")," is the abi encoded data that comprises of:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"destContractAddress:")," Address of the contract which will be called after the transfer is complete. This contract needs to implement the voyagerReceive function (details given below)."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"data:")," This is the abi encoded arguments that will be passed to the function that should be called on the destination contract address. The data should exclude the address and amount of tokens received as the amount may vary according to the fees. The address of the token and exact amount of tokens received by the user will be accessible into the handler function directly on the destination chain."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"gasLimit:")," The gas limit required for your function to be executed on the destination chain. The fees that we deduct from you will depend on this."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"gasPrice:")," Current gas price of the destination chain. The fees that we deduct from you will depend on this.")),(0,a.kt)("h3",{id:"voyagerreceive"},(0,a.kt)("code",null,"voyagerReceive")),(0,a.kt)("p",null,"The arbitrary instruction that you provide here will be executed on the destination chain on the contract address that you specify. That contract must implement the ",(0,a.kt)("strong",{parentName:"p"},"voyagerReceive")," function given below."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"function voyagerReceive(\n        address sourceSenderAddress,\n        bytes32 srcChainIdBytes,\n        bytes memory data,\n        address settlementToken,\n        uint256 settlementAmount\n    ) external;\n")),(0,a.kt)("p",null,"With this function, you will receive:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"sourceSenderAddress:")," the address of the sender of transaction from the source chain."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"srcChainIdBytes:")," the identifier of the source chain."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"data:")," Data for the params to the function for which the selector was received passed from the source chain."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"settlementToken:")," Address of the token which was received to the recipient after the transfer."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"settlementAmount:")," Amount of the settlement tokens received to the recipient after the transfer.")),(0,a.kt)("p",null,"Inside the ",(0,a.kt)("strong",{parentName:"p"},"voyagerReceive")," function on the destination chain, you will decode the data according to the requirements of the function selector and call that function which will complete the instruction execution."))}u.isMDXComponent=!0}}]);