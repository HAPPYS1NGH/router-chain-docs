"use strict";(self.webpackChunkrouter_docs=self.webpackChunkrouter_docs||[]).push([[4138],{3905:(e,n,t)=>{t.d(n,{Zo:()=>d,kt:()=>m});var r=t(67294);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)t=i[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var c=r.createContext({}),l=function(e){var n=r.useContext(c),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},d=function(e){var n=l(e.components);return r.createElement(c.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},p=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,i=e.originalType,c=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),p=l(t),m=a,f=p["".concat(c,".").concat(m)]||p[m]||u[m]||i;return t?r.createElement(f,s(s({ref:n},d),{},{components:t})):r.createElement(f,s({ref:n},d))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var i=t.length,s=new Array(i);s[0]=p;var o={};for(var c in n)hasOwnProperty.call(n,c)&&(o[c]=n[c]);o.originalType=e,o.mdxType="string"==typeof e?e:a,s[1]=o;for(var l=2;l<i;l++)s[l]=t[l];return r.createElement.apply(null,s)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},43388:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var r=t(87462),a=(t(67294),t(3905));const i={title:"Sample Delayed Execution ASM Contract",sidebar_position:3},s=void 0,o={unversionedId:"message-transfer-via-crosstalk/near-guides/asm-implementation/sample-delayed-execution-asm-contract",id:"message-transfer-via-crosstalk/near-guides/asm-implementation/sample-delayed-execution-asm-contract",title:"Sample Delayed Execution ASM Contract",description:"A delayed execution ASM deliberately delays a cross-chain request by a certain period to force the validation of the request only once a certain amount of time has lapsed. After the request is delayed, the owner has the flexibility to reject the transaction if there is something malicious or invalid with the transaction.",source:"@site/docs/develop/message-transfer-via-crosstalk/near-guides/asm-implementation/sample-delayed-execution-asm-contract.md",sourceDirName:"message-transfer-via-crosstalk/near-guides/asm-implementation",slug:"/message-transfer-via-crosstalk/near-guides/asm-implementation/sample-delayed-execution-asm-contract",permalink:"/develop/message-transfer-via-crosstalk/near-guides/asm-implementation/sample-delayed-execution-asm-contract",draft:!1,editUrl:"https://github.com/router-protocol/docs/tree/main/docs/develop/message-transfer-via-crosstalk/near-guides/asm-implementation/sample-delayed-execution-asm-contract.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Sample Delayed Execution ASM Contract",sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Integrate ASM into Your Application",permalink:"/develop/message-transfer-via-crosstalk/near-guides/asm-implementation/integrate-asm-into-your-application"},next:{title:"Router Chain Guides",permalink:"/develop/message-transfer-via-crosstalk/router-chain-guides/"}},c={},l=[],d={toc:l};function u(e){let{components:n,...t}=e;return(0,a.kt)("wrapper",(0,r.Z)({},d,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"A delayed execution ASM deliberately delays a cross-chain request by a certain period to force the validation of the request only once a certain amount of time has lapsed. After the request is delayed, the owner has the flexibility to reject the transaction if there is something malicious or invalid with the transaction."),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},'use ethabi::{encode, ethereum_types::U256, Token};\nuse near_sdk::{\n    borsh::{self, BorshDeserialize, BorshSerialize},\n    collections::UnorderedMap,\n    env::{self, keccak256},\n    json_types::U128,\n    near_bindgen, AccountId, PanicOnDefault,\n};\n\n// Define the contract structure\n#[near_bindgen]\n#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)]\npub struct DelayAsm {\n    delayed_transfers: UnorderedMap<Vec<u8>, bool>,\n    gateway_contract: AccountId,\n    delay_period: U128,\n    owner: AccountId,\n}\n\n// Implement the contract structure\n#[near_bindgen]\nimpl DelayAsm {\n    #[init]\n    pub fn new(gateway: AccountId, delay_period: U128) -> Self {\n        Self {\n            delayed_transfers: UnorderedMap::new(b"D"),\n            gateway_contract: gateway,\n            delay_period,\n            owner: env::predecessor_account_id(),\n        }\n    }\n\n    pub fn get_gateway(&self) -> AccountId {\n        self.gateway_contract.clone()\n    }\n\n    pub fn get_delay_period(&self) -> U128 {\n        self.delay_period.clone()\n    }\n\n    pub fn is_request_rejected(&self, id: Vec<u8>) -> bool {\n        self.delayed_transfers.get(&id).unwrap_or(false)\n    }\n\n    pub fn get_owner(&self) -> AccountId {\n        self.owner.clone()\n    }\n\n    pub fn set_gateway(&mut self, gateway: AccountId) {\n        if self.owner.clone() != env::predecessor_account_id() {\n            env::panic_str("only owner");\n        }\n\n        self.gateway_contract = gateway;\n    }\n\n    pub fn set_delay_period(&mut self, delay_period: U128) {\n        if self.owner.clone() != env::predecessor_account_id() {\n            env::panic_str("only owner");\n        }\n\n        self.delay_period = delay_period;\n    }\n\n    pub fn reject_request(&mut self, id: Vec<u8>) {\n        if self.owner.clone() != env::predecessor_account_id() {\n            env::panic_str("only owner");\n        }\n\n        self.delayed_transfers.insert(&id, &true);\n    }\n\n    fn get_id(\n        request_identifier: U128,\n        request_timestamp: U128,\n        src_chain_id: String,\n        request_sender: String,\n        packet: Vec<u8>,\n        handler: AccountId,\n    ) -> Vec<u8> {\n        let request_id_u256: U256 = U256::from(u128::from(request_identifier));\n        let request_id_token: Token = Token::Uint(request_id_u256);\n\n        let request_timestamp_u256: U256 = U256::from(u128::from(request_timestamp));\n        let request_timestamp_token: Token = Token::Uint(request_timestamp_u256);\n\n        let src_chain_id_token: Token = Token::String(src_chain_id);\n        let request_sender_token: Token = Token::String(request_sender);\n        let packet_token: Token = Token::Bytes(packet);\n        let handler_token: Token = Token::String(handler.to_string());\n\n        let id: Vec<u8> = encode(&[\n            request_id_token,\n            request_timestamp_token,\n            request_sender_token,\n            src_chain_id_token,\n            packet_token,\n            handler_token,\n        ]);\n\n        keccak256(&id)\n    }\n\n    pub fn verify_cross_chain_request(\n        &mut self,\n        request_identifier: U128,\n        request_timestamp: U128,\n        src_chain_id: String,\n        request_sender: String,\n        packet: Vec<u8>,\n        handler: AccountId,\n    ) -> bool {\n        if self.gateway_contract.clone() != env::predecessor_account_id() {\n            env::panic_str("Caller is not gateway");\n        }\n\n        let id: Vec<u8> = Self::get_id(\n            request_identifier,\n            request_timestamp,\n            src_chain_id,\n            request_sender,\n            packet,\n            handler,\n        );\n\n        if self.delayed_transfers.get(&id).unwrap_or(false) {\n            return false;\n        }\n\n        let current_timestamp: u64 = env::block_timestamp().checked_div(1000000000).unwrap();\n\n        if U128::from(u128::from(current_timestamp))\n            > U128::from(u128::from(request_timestamp) + u128::from(self.delay_period))\n        {\n            return true;\n        }\n\n        env::panic_str("Transaction needs to be delayed");\n    }\n}\n')),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"The owner of the ASM contract can set the\xa0",(0,a.kt)("inlineCode",{parentName:"p"},"delay_period"),", which is the period that must pass before transactions can be executed on the destination contract once they have been validated on the Router chain."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},'pub fn set_delay_period(&mut self, delay_period: U128) {\n  if self.owner.clone() != env::predecessor_account_id() {\n      env::panic_str("only owner");\n  }\n\n  self.delay_period = delay_period;\n}\n'))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"The Gateway contract invokes the\xa0",(0,a.kt)("inlineCode",{parentName:"p"},"verify_cross_chain_request"),"\xa0function before invoking the destination contract. It checks whether the transaction (a) has been rejected by the owner of the ASM contract, (b) is delayed or, (c) has reached the delay period."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},'pub fn verify_cross_chain_request(\n  &mut self,\n  request_identifier: U128,\n  request_timestamp: U128,\n  src_chain_id: String,\n  request_sender: String,\n  packet: Vec<u8>,\n  handler: AccountId,\n) -> bool {\n  if self.gateway_contract.clone() != env::predecessor_account_id() {\n      env::panic_str("Caller is not gateway");\n  }\n\n  let id: Vec<u8> = Self::get_id(\n      request_identifier,\n      request_timestamp,\n      src_chain_id,\n      request_sender,\n      packet,\n      handler,\n  );\n\n  if self.delayed_transfers.get(&id).unwrap_or(false) {\n      return false;\n  }\n\n  let current_timestamp: u64 = env::block_timestamp().checked_div(1000000000).unwrap();\n\n  if U128::from(u128::from(current_timestamp))\n      > U128::from(u128::from(request_timestamp) + u128::from(self.delay_period))\n  {\n      return true;\n  }\n\n  env::panic_str("Transaction needs to be delayed");\n}\n'))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"The owner of the contract can reject a transaction by its ",(0,a.kt)("inlineCode",{parentName:"p"},"ID"),", which is the ABI-encoded function arguments in order."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},'pub fn reject_request(&mut self, id: Vec<u8>) {\n  if self.owner.clone() != env::predecessor_account_id() {\n      env::panic_str("only owner");\n  }\n\n  self.delayed_transfers.insert(&id, &true);\n}\n'))),(0,a.kt)("li",{parentName:"ul"},(0,a.kt)("p",{parentName:"li"},"The\xa0",(0,a.kt)("inlineCode",{parentName:"p"},"is_request_rejected")," function checks whether a transaction has been rejected by the owner or not."),(0,a.kt)("pre",{parentName:"li"},(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"pub fn is_request_rejected(&self, id: Vec<u8>) -> bool {\n  self.delayed_transfers.get(&id).unwrap_or(false)\n}\n")))))}u.isMDXComponent=!0}}]);