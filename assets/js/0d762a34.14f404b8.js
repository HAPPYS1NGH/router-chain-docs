"use strict";(self.webpackChunkrouter_docs=self.webpackChunkrouter_docs||[]).push([[4681],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>d});var n=r(67294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var c=n.createContext({}),l=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},u=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=l(r),d=a,m=p["".concat(c,".").concat(d)]||p[d]||h[d]||o;return r?n.createElement(m,i(i({ref:t},u),{},{components:r})):n.createElement(m,i({ref:t},u))}));function d(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,i=new Array(o);i[0]=p;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var l=2;l<o;l++)i[l]=r[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}p.displayName="MDXCreateElement"},76388:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>o,metadata:()=>s,toc:()=>l});var n=r(87462),a=(r(67294),r(3905));const o={sidebar_position:1},i="Introduction",s={unversionedId:"README",id:"README",title:"Introduction",description:"What is Router Chain?",source:"@site/docs/overview/README.md",sourceDirName:".",slug:"/",permalink:"/overview/",draft:!1,editUrl:"https://github.com/router-protocol/docs/tree/main/docs/overview/README.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{sidebar_position:1},sidebar:"tutorialSidebar",next:{title:"Choosing the Right Cross-chain Framework",permalink:"/overview/choosing-the-right-framework"}},c={},l=[{value:"What is Router Chain?",id:"what-is-router-chain",level:2},{value:"Router Chain as an Interoperability Layer",id:"router-chain-as-an-interoperability-layer",level:2},{value:"Communication via Router CrossTalk",id:"communication-via-router-crosstalk",level:2},{value:"Global Liquidity via Voyager",id:"global-liquidity-via-voyager",level:2}],u={toc:l};function h(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"introduction"},"Introduction"),(0,a.kt)("h2",{id:"what-is-router-chain"},"What is Router Chain?"),(0,a.kt)("p",null,"The Router chain is a layer 1 blockchain that leverages tendermint\u2019s Byzantine Fault Tolerant (BFT) consensus engine. As a Proof of Stake (PoS) blockchain, the Router chain is primarily run by a network of validators with economic incentives to act honestly. The Router chain is built using the Cosmos SDK and encapsulates all the features of Cosmos, including fast block times, robust security mechanisms, and, most importantly, CosmWasm - a security-first smart contract platform. By leveraging the CosmWasm toolkit, developers can start building secure blockchain applications on the Router chain from scratch or port their existing applications to the Router chain with minimal overhead."),(0,a.kt)("h2",{id:"router-chain-as-an-interoperability-layer"},"Router Chain as an Interoperability Layer"),(0,a.kt)("p",null,"In addition to its functionalities as a blockchain network, the Router chain provides an innovative\nsolution to the problem of blockchain interoperability. Apart from validating state changes on the Router\nchain, validators running on the Router chain can also monitor state changes on other chains. Applications\non the Router chain can write custom logic to trigger events in response to these external state changes.\nAdditionally, applications on the Router chain can leverage a trustless network of relayers to update\nstates on external chains. Simply put, the Router architecture allows contracts on one chain to interact\nwith contracts on other chains in a secure and decentralized manner. "),(0,a.kt)("h2",{id:"communication-via-router-crosstalk"},"Communication via Router CrossTalk"),(0,a.kt)("p",null,"Router's CrossTalk library is an extensible cross-chain framework that enables seamless state transitions across multiple chains. In simple terms, this library abstracts Router's functionalities to allow contracts on one chain to pass instructions to contracts deployed on some other chain. The library is structured in a way that it can be integrated seamlessly into your development environment to allow for cross-chain message passing without disturbing other parts of your product. "),(0,a.kt)("p",null,"CrossTalk supports both stateful and stateless bridging:"),(0,a.kt)("ul",null,(0,a.kt)("li",{parentName:"ul"},"For cross-chain dApps that require custom bridging logic between any two chains, developers can build and deploy middleware contracts on the Router chain. All cross-chain requests originating from the dApp's source chain contract will come to this middleware contract where some actions can be performed before they are forwarded to the intended destination chain."),(0,a.kt)("li",{parentName:"ul"},"For dApps that do not require any custom bridging logic or any data aggregation layer in the middle, no middleware contract is required. ")),(0,a.kt)("h2",{id:"global-liquidity-via-voyager"},"Global Liquidity via Voyager"),(0,a.kt)("p",null,"Voyager is a cross-chain swapping engine that allows for cross-chain asset transfers as well as cross-chain sequencing of asset transfers and arbitrary instruction transfers. Voyager has a whole development suite around it, which includes:"),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},"a widget that can be used by other projects to give their users an option to perform cross-chain transactions directly from their UI;"),(0,a.kt)("li",{parentName:"ol"},"an API and a SDK that abstracts Voyager's backend capabilities for projects that want to use their own UI/platform for offering the cross-chain asset swap functionality;"),(0,a.kt)("li",{parentName:"ol"},"most importantly, the sequencer library, which allows developers to build cross-chain applications that require both asset transfer and instruction transfer in a single cross-chain request.")))}h.isMDXComponent=!0}}]);