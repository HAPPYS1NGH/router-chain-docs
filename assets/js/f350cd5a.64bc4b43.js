"use strict";(self.webpackChunkrouter_docs=self.webpackChunkrouter_docs||[]).push([[3330],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>p});var n=r(67294);function a(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function o(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?o(Object(r),!0).forEach((function(t){a(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):o(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,n,a=function(e,t){if(null==e)return{};var r,n,a={},o=Object.keys(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||(a[r]=e[r]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(n=0;n<o.length;n++)r=o[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(a[r]=e[r])}return a}var c=n.createContext({}),l=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},u=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},f=n.forwardRef((function(e,t){var r=e.components,a=e.mdxType,o=e.originalType,c=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),f=l(r),p=a,g=f["".concat(c,".").concat(p)]||f[p]||d[p]||o;return r?n.createElement(g,s(s({ref:t},u),{},{components:r})):n.createElement(g,s({ref:t},u))}));function p(e,t){var r=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=r.length,s=new Array(o);s[0]=f;var i={};for(var c in t)hasOwnProperty.call(t,c)&&(i[c]=t[c]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var l=2;l<o;l++)s[l]=r[l];return n.createElement.apply(null,s)}return n.createElement.apply(null,r)}f.displayName="MDXCreateElement"},97481:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var n=r(87462),a=(r(67294),r(3905));const o={},s="TExchange",i={unversionedId:"message-transfer-via-crosstalk/stateful-bridging/texchange/README",id:"message-transfer-via-crosstalk/stateful-bridging/texchange/README",title:"TExchange",description:"Background",source:"@site/docs/develop/message-transfer-via-crosstalk/stateful-bridging/texchange/README.md",sourceDirName:"message-transfer-via-crosstalk/stateful-bridging/texchange",slug:"/message-transfer-via-crosstalk/stateful-bridging/texchange/",permalink:"/develop/message-transfer-via-crosstalk/stateful-bridging/texchange/",draft:!1,editUrl:"https://github.com/router-protocol/docs/tree/main/docs/develop/message-transfer-via-crosstalk/stateful-bridging/texchange/README.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"High Level Architecture",permalink:"/develop/message-transfer-via-crosstalk/stateful-bridging/high-level-architecture"},next:{title:"Architecture",permalink:"/develop/message-transfer-via-crosstalk/stateful-bridging/texchange/architecture"}},c={},l=[{value:"Background",id:"background",level:2},{value:"Motivation",id:"motivation",level:2}],u={toc:l};function d(e){let{components:t,...r}=e;return(0,a.kt)("wrapper",(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"texchange"},"TExchange"),(0,a.kt)("h2",{id:"background"},"Background"),(0,a.kt)("p",null,"One of the challenges that all developers face is acquisition of the testnet native tokens. To be able to deploy a contract or for testing, developers need testnet native tokens. Currently, there are multiple faucets that are available for developers to access and get the testnet tokens. However, the challenge remains that the faucets are either not in a working state or are already dried up and have no tokens to give out. This makes life difficult for the developers as they are not able to deploy and test dapps on testnet easily. It also ends up consuming a lot of time for the developers to search for a good working faucet and then get these tokens. In case a developer is able to find out a good faucet, even then, to get a large number of test tokens, they need to go through the pain of creating multiple accounts and trying to request through them, as most faucets have withdrawal limits per account or IP address."),(0,a.kt)("h2",{id:"motivation"},"Motivation"),(0,a.kt)("p",null,"To ease the life of developers, a testnet native token marketplace has been built. In this marketplace, users can trade their testnet native tokens for another testnet native token of their choice. E.g., if a developer has lots of Mumbai Matic and wants Kovan ETH, they can come to this dapp and trade Mumbai Matic for Kovan ETH.\nDevelopers can even buy these testnet tokens by paying for them using USDC. A developer who has a lot of testnet tokens can utilize this dApp to sell their accumulated tokens for real USDC and gain monetary benefit from it."))}d.isMDXComponent=!0}}]);