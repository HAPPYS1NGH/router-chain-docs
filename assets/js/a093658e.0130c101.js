"use strict";(self.webpackChunkrouter_docs=self.webpackChunkrouter_docs||[]).push([[5015],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>p});var n=r(67294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function a(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,n)}return r}function i(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?a(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):a(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function s(e,t){if(null==e)return{};var r,n,o=function(e,t){if(null==e)return{};var r,n,o={},a=Object.keys(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(n=0;n<a.length;n++)r=a[n],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var c=n.createContext({}),l=function(e){var t=n.useContext(c),r=t;return e&&(r="function"==typeof e?e(t):i(i({},t),e)),r},u=function(e){var t=l(e.components);return n.createElement(c.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},d=n.forwardRef((function(e,t){var r=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=l(r),p=o,m=d["".concat(c,".").concat(p)]||d[p]||h[p]||a;return r?n.createElement(m,i(i({ref:t},u),{},{components:r})):n.createElement(m,i({ref:t},u))}));function p(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=r.length,i=new Array(a);i[0]=d;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:o,i[1]=s;for(var l=2;l<a;l++)i[l]=r[l];return n.createElement.apply(null,i)}return n.createElement.apply(null,r)}d.displayName="MDXCreateElement"},45301:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>h,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var n=r(87462),o=(r(67294),r(3905));const a={title:"Choosing the Right Cross-chain Framework",sidebar_position:2},i=void 0,s={unversionedId:"choosing-the-right-framework",id:"choosing-the-right-framework",title:"Choosing the Right Cross-chain Framework",description:"Router Protocol provides three ways using which developers can build cross-chain applications, namely -",source:"@site/docs/overview/choosing-the-right-framework.md",sourceDirName:".",slug:"/choosing-the-right-framework",permalink:"/overview/choosing-the-right-framework",draft:!1,editUrl:"https://github.com/router-protocol/docs/tree/main/docs/overview/choosing-the-right-framework.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Choosing the Right Cross-chain Framework",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Introduction",permalink:"/overview/"},next:{title:"Governance",permalink:"/overview/governance"}},c={},l=[{value:"OmniChain Framework",id:"omnichain-framework",level:3},{value:"CrossTalk Framework",id:"crosstalk-framework",level:3},{value:"Voyager",id:"voyager",level:3}],u={toc:l};function h(e){let{components:t,...r}=e;return(0,o.kt)("wrapper",(0,n.Z)({},u,r,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"Router Protocol provides three ways using which developers can build cross-chain applications, namely -"),(0,o.kt)("ol",null,(0,o.kt)("li",{parentName:"ol"},"OmniChain framework (middleware contracts on the Router chain)"),(0,o.kt)("li",{parentName:"ol"},"CrossTalk framework"),(0,o.kt)("li",{parentName:"ol"},"Voyager (leveraging global liquidity with message transfers)")),(0,o.kt)("p",null,"Since all three offer different features, it is crucial to understand which framework best suits your requirements before using it in your dApp. "),(0,o.kt)("h3",{id:"omnichain-framework"},"OmniChain Framework"),(0,o.kt)("p",null,"This is the framework for you if you want to build an application that requires custom bridging logic or a decentralized accounting layer. For example, you can use this framework to create a multi-chain NFT collection with a single place to maintain the list of all the NFTs minted on different chains. If you wanted to use existing solutions, you'd have to maintain this list on all the chains where your dApp is deployed. In this case, by removing the redundancy involved in accounting, a CosmWasm contract on the Router chain act as a data aggregation layer. Another potential dApp that can benefit from Router's middleware capabilities is a cross-chain DEX. You'll need to deploy the token-swapping logic only on the Router chain, while smart contracts on other chains only need to include the locking/unlocking logic. "),(0,o.kt)("h3",{id:"crosstalk-framework"},"CrossTalk Framework"),(0,o.kt)("p",null,"For cross-chain instruction transfers that do not require any logic in the middle or do not need any accounting layer, Router's CrossTalk framework is the best option. It is an easy-to-implement cross-chain smart contract library that does not require you to deploy any new contract - only a few lines of code need to be included, and your single-chain contract will become a cross-chain contract. CrossTalk's ability to transfer multiple contract-level instructions in a single cross-chain call makes it a very powerful tool. More about CrossTalk's capabilities has been included in the ",(0,o.kt)("a",{parentName:"p",href:"../crosstalk/understanding-crosstalk/"},(0,o.kt)("strong",{parentName:"a"},"Understanding CrossTalk")," section")," of the developer documentation. Various dApps like cross-chain NFTs (burning an NFT on one chain and minting it on another) and cross-chain lending/borrowing applications (enabling a borrower to provide collateral on one chain and then transferring an instruction to mint/unlock the borrower's desired token on the destination chain) can be built using this framework."),(0,o.kt)("h3",{id:"voyager"},"Voyager"),(0,o.kt)("p",null,"Voyager is the native cross-chain asset-transfer bridge built using Router's OmniChain framework. It acts as the gateway to the liquidity managed by Router Protocol. Developers can use Voyager to access this liquidity and build either (a) other asset-transfer applications or (b) applications requiring both an asset transfer and an instruction transfer in a single sequenced cross-chain request. A very good example of the latter is a cross-chain yield aggregator that needs to transfer users' funds and an instruction to stake them in a particular contract, both in a single cross-chain request."))}h.isMDXComponent=!0}}]);