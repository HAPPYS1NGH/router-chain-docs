"use strict";(self.webpackChunkrouter_docs=self.webpackChunkrouter_docs||[]).push([[48],{3905:(e,t,r)=>{r.d(t,{Zo:()=>u,kt:()=>p});var a=r(67294);function o(e,t,r){return t in e?Object.defineProperty(e,t,{value:r,enumerable:!0,configurable:!0,writable:!0}):e[t]=r,e}function n(e,t){var r=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),r.push.apply(r,a)}return r}function s(e){for(var t=1;t<arguments.length;t++){var r=null!=arguments[t]?arguments[t]:{};t%2?n(Object(r),!0).forEach((function(t){o(e,t,r[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(r)):n(Object(r)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(r,t))}))}return e}function i(e,t){if(null==e)return{};var r,a,o=function(e,t){if(null==e)return{};var r,a,o={},n=Object.keys(e);for(a=0;a<n.length;a++)r=n[a],t.indexOf(r)>=0||(o[r]=e[r]);return o}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(a=0;a<n.length;a++)r=n[a],t.indexOf(r)>=0||Object.prototype.propertyIsEnumerable.call(e,r)&&(o[r]=e[r])}return o}var l=a.createContext({}),c=function(e){var t=a.useContext(l),r=t;return e&&(r="function"==typeof e?e(t):s(s({},t),e)),r},u=function(e){var t=c(e.components);return a.createElement(l.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var r=e.components,o=e.mdxType,n=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),d=c(r),p=o,m=d["".concat(l,".").concat(p)]||d[p]||h[p]||n;return r?a.createElement(m,s(s({ref:t},u),{},{components:r})):a.createElement(m,s({ref:t},u))}));function p(e,t){var r=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var n=r.length,s=new Array(n);s[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:o,s[1]=i;for(var c=2;c<n;c++)s[c]=r[c];return a.createElement.apply(null,s)}return a.createElement.apply(null,r)}d.displayName="MDXCreateElement"},7948:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>h,frontMatter:()=>n,metadata:()=>i,toc:()=>c});var a=r(87462),o=(r(67294),r(3905));const n={title:"Orchestrators",sidebar_position:2},s="Orchestrators",i={unversionedId:"orchestrators",id:"orchestrators",title:"Orchestrators",description:"Router orchestrators are entities who listen to various inbound events from other chains, attest their validity, and forward them to the Router chain. They are also responsible for attesting the validity of outbound requests before they can be picked up by the relayers. All validators must run an orchestrator instance to be a part of the Router chain ecosystem.",source:"@site/docs/validators/orchestrators.md",sourceDirName:".",slug:"/orchestrators",permalink:"/validators/orchestrators",draft:!1,editUrl:"https://github.com/router-protocol/docs/tree/main/docs/validators/orchestrators.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Orchestrators",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Overview",permalink:"/validators/"},next:{title:"PoS Validation",permalink:"/validators/pos-validation"}},l={},c=[{value:"Working of an Orchestrator",id:"working-of-an-orchestrator",level:2},{value:"Addressing Orchestrator Scalability",id:"addressing-orchestrator-scalability",level:2}],u={toc:c};function h(e){let{components:t,...n}=e;return(0,o.kt)("wrapper",(0,a.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"orchestrators"},"Orchestrators"),(0,o.kt)("p",null,"Router orchestrators are entities who listen to various inbound events from other chains, attest their validity, and forward them to the Router chain. They are also responsible for attesting the validity of outbound requests before they can be picked up by the relayers. All validators must run an orchestrator instance to be a part of the Router chain ecosystem."),(0,o.kt)("h2",{id:"working-of-an-orchestrator"},"Working of an Orchestrator"),(0,o.kt)("p",null,"At a high level, a Router orchestrator works like a funnel that gathers events from various chains and posts them to the Router chain. To do so, an orchestrator uses a listener and dispatcher model wherein the listener module aggregates events while the dispatcher module forwards these events to the Router chain."),(0,o.kt)("center",null,(0,o.kt)("img",{src:r(3172).Z,alt:"Orchestrator Architecture",style:{width:700,marginBottom:12}})),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Listener:")," The listener module of an orchestrator listens to events emitted from specific chains based on the ",(0,o.kt)("strong",{parentName:"li"},(0,o.kt)("inlineCode",{parentName:"strong"},"chainType"))," parameter in the configuration provided to it. Listeners operate as threads (goroutines) under an orchestrator. All listeners subscribe to multiple types of events, including a regular inbound request, an acknowledgment request, and a CrossTalk request, among others. Once the listener module receives an event, irrespective of its type, it parses the event into the same format. Once the message is prepared, the listener adds it to the messaging queue."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Message Queue:")," The message queues are used to enqueue and deliver transformed messages to consumers (dispatchers) in a first-in-first-out manner while ensuring that duplicate messages are automatically discarded."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Dispatcher:")," The dispatcher module is essentially responsible for streamlining the incoming requests by (a) listening to the message queue, (b) signing the messages, and (c) broadcasting them to the Router chain.  ")),(0,o.kt)("p",null,"As mentioned above, orchestrators also verify the pending requests on the outbound module. To do so, an orchestrator has to listen to the transactions occurring on the Router chain."),(0,o.kt)("h2",{id:"addressing-orchestrator-scalability"},"Addressing Orchestrator Scalability"),(0,o.kt)("p",null,"Listening to multiple blockchains at the same time is a resource-intensive task, and therefore, proper measures need to be taken to guarantee the scalability of the orchestrator module:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"Multiple Threads:")," Each orchestrator can run multiple listeners as goroutines/threads, each responsible for listening to one specific chain for Router-specific events. On top of the scalability it provides, this approach allows us to remain modular in our design. For chains that do not have support for Golang, instead of developing a new orchestrator, we can just build listeners and attach them to existing orchestrators to continue the operation."),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("strong",{parentName:"li"},"RabbitMQ for Message Queuing:")," Orchestrators on the Router chain use ",(0,o.kt)("a",{parentName:"li",href:"https://www.rabbitmq.com/"},"RabbitMQ"),", a dedicated message broker, to handle the message passing between the listener and the dispatcher module. RabbitMQ\u2019s ability to maintain states (messages) until they are received allows for rollbacks and failover handling without any overhead.")))}h.isMDXComponent=!0},3172:(e,t,r)=>{r.d(t,{Z:()=>a});const a=r.p+"assets/images/orchestrator-26b0f8cc721ef5606b766f6bc7ca02c4.png"}}]);