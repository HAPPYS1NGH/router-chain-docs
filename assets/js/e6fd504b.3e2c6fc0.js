"use strict";(self.webpackChunkrouter_docs=self.webpackChunkrouter_docs||[]).push([[7190],{3905:(e,t,n)=>{n.d(t,{Zo:()=>u,kt:()=>f});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function i(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)n=o[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=r.createContext({}),c=function(e){var t=r.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},u=function(e){var t=c(e.components);return r.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,u=i(e,["components","mdxType","originalType","parentName"]),d=c(n),f=a,h=d["".concat(l,".").concat(f)]||d[f]||p[f]||o;return n?r.createElement(h,s(s({ref:t},u),{},{components:n})):r.createElement(h,s({ref:t},u))}));function f(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,s=new Array(o);s[0]=d;var i={};for(var l in t)hasOwnProperty.call(t,l)&&(i[l]=t[l]);i.originalType=e,i.mdxType="string"==typeof e?e:a,s[1]=i;for(var c=2;c<o;c++)s[c]=n[c];return r.createElement.apply(null,s)}return r.createElement.apply(null,n)}d.displayName="MDXCreateElement"},6613:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>i,toc:()=>c});var r=n(87462),a=(n(67294),n(3905));const o={title:"Transfer of Non-Reserve Tokens",sidebar_position:4},s=void 0,i={unversionedId:"understanding-voyager/transfer-non-reserve-token",id:"understanding-voyager/transfer-non-reserve-token",title:"Transfer of Non-Reserve Tokens",description:"Non-Reserve tokens include all those tokens which are not kept as reserve tokens for the Voyager and are not the LP tokens for any of these reserve tokens. These can be any random token.",source:"@site/docs/voyager/understanding-voyager/transfer-non-reserve-token.md",sourceDirName:"understanding-voyager",slug:"/understanding-voyager/transfer-non-reserve-token",permalink:"/voyager/understanding-voyager/transfer-non-reserve-token",draft:!1,editUrl:"https://github.com/router-protocol/docs/tree/main/docs/voyager/understanding-voyager/transfer-non-reserve-token.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{title:"Transfer of Non-Reserve Tokens",sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Transfer of Reserve Tokens with Arbitrary Instruction",permalink:"/voyager/understanding-voyager/transfer-reserve-token-arbitrary-instruction"},next:{title:"Transfer of Non-Reserve Tokens with Arbitrary Instruction",permalink:"/voyager/understanding-voyager/transfer-non-reserve-token-arbitrary-instruction"}},l={},c=[],u={toc:c};function p(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},u,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"function depositNonReserveToken(\n    bool isSourceNative,\n    bytes memory swapData,\n    bytes memory executeData\n) external payable\n")),(0,a.kt)("p",null,"Non-Reserve tokens include all those tokens which are not kept as reserve tokens for the Voyager and are not the LP tokens for any of these reserve tokens. These can be any random token. "),(0,a.kt)("p",null,"When a user wants to transfer any non-reserve token from source chain to any other token on the destination chain, this function is to be called. After this function is called, the Voyager\u2019s infrastructure will handle the transfer of tokens to the other chain."),(0,a.kt)("p",null,(0,a.kt)("strong",{parentName:"p"},"Parameters:")),(0,a.kt)("table",null,(0,a.kt)("thead",{parentName:"table"},(0,a.kt)("tr",{parentName:"thead"},(0,a.kt)("th",{parentName:"tr",align:null},"isSourceNative"),(0,a.kt)("th",{parentName:"tr",align:null},"If the source token is the native token for that chain, this should be true."))),(0,a.kt)("tbody",{parentName:"table"},(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"swapData"),(0,a.kt)("td",{parentName:"tr",align:null},"abi encoded data for the swap which is created by an API")),(0,a.kt)("tr",{parentName:"tbody"},(0,a.kt)("td",{parentName:"tr",align:null},"executeData"),(0,a.kt)("td",{parentName:"tr",align:null},"abi encoded data for the destination chain which is created by an API")))),(0,a.kt)("p",null,"The ",(0,a.kt)("strong",{parentName:"p"},"Swap Data")," includes: "),(0,a.kt)("ol",null,(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"srcTokenAmount:")," Amount of the non-reserve token the user wants to transfer to the other chain."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"srcStableTokenAmount:")," Amount of the stable token equivalent to the amount of source token user wants to transfer."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"destChainIdBytes:")," The Chain ID identifier for the destination chain."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"srcTokenAddress:")," Address of the token the user wants to transfer to the other chain. "),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"srcStableTokenAddress:")," Address of the stable token in which the stable amount (srcStableTokenAmount) equivalent to the srcTokenAmount is calculated."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"dataTx:")," Data for the transaction for swap to convert the non-reserve token to the stable token on source chain (received from the API)."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"path:")," Data for the transaction for swap to convert the non-reserve token to the stable token on source chain (received from the API)."),(0,a.kt)("li",{parentName:"ol"},(0,a.kt)("strong",{parentName:"li"},"flags:")," The identifiers of DEXes that will be used for swap on source chain (received from the API).")),(0,a.kt)("p",null,"The details for the Execute Data can be found ",(0,a.kt)("a",{parentName:"p",href:"./transfer-reserve-token#execute-data"},"here"),"."),(0,a.kt)("admonition",{type:"info"},(0,a.kt)("p",{parentName:"admonition"},"\ud83d\udca1 Note: All these data will directly be generated by the API. You don\u2019t need to worry about generating this data.")))}p.isMDXComponent=!0}}]);