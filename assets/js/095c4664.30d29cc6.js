"use strict";(self.webpackChunkrouter_docs=self.webpackChunkrouter_docs||[]).push([[7388],{3905:(e,t,a)=>{a.d(t,{Zo:()=>d,kt:()=>h});var n=a(67294);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function s(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var l=n.createContext({}),c=function(e){var t=n.useContext(l),a=t;return e&&(a="function"==typeof e?e(t):s(s({},t),e)),a},d=function(e){var t=c(e.components);return n.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},p=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),p=c(a),h=r,m=p["".concat(l,".").concat(h)]||p[h]||u[h]||i;return a?n.createElement(m,s(s({ref:t},d),{},{components:a})):n.createElement(m,s({ref:t},d))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,s=new Array(i);s[0]=p;var o={};for(var l in t)hasOwnProperty.call(t,l)&&(o[l]=t[l]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var c=2;c<i;c++)s[c]=a[c];return n.createElement.apply(null,s)}return n.createElement.apply(null,a)}p.displayName="MDXCreateElement"},46106:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>c});var n=a(87462),r=(a(67294),a(3905));const i={title:"Sample Read Request Contract",sidebar_position:3},s=void 0,o={unversionedId:"message-transfer-via-crosstalk/evm-guides/cross-chain-read-requests/sample-read-request-contract",id:"message-transfer-via-crosstalk/evm-guides/cross-chain-read-requests/sample-read-request-contract",title:"Sample Read Request Contract",description:"This section explains how to create a simple cross-chain read request contract by integrating the Router Gateway contracts. The assumption made here is that a random contract already exists on the destination chain that retrieves a certain value from the source chain.",source:"@site/docs/develop/message-transfer-via-crosstalk/evm-guides/cross-chain-read-requests/sample-read-request-contract.md",sourceDirName:"message-transfer-via-crosstalk/evm-guides/cross-chain-read-requests",slug:"/message-transfer-via-crosstalk/evm-guides/cross-chain-read-requests/sample-read-request-contract",permalink:"/develop/message-transfer-via-crosstalk/evm-guides/cross-chain-read-requests/sample-read-request-contract",draft:!1,editUrl:"https://github.com/router-protocol/docs/tree/main/docs/develop/message-transfer-via-crosstalk/evm-guides/cross-chain-read-requests/sample-read-request-contract.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{title:"Sample Read Request Contract",sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"Handling the Acknowledgment on the Source Chain",permalink:"/develop/message-transfer-via-crosstalk/evm-guides/cross-chain-read-requests/handling-the-acknowledgment-on-the-source-chain"},next:{title:"ASM Implementation",permalink:"/develop/message-transfer-via-crosstalk/evm-guides/asm-implementation/"}},l={},c=[{value:"Step 1) Installing the dependencies",id:"step-1-installing-the-dependencies",level:3},{value:"Step 2) Instantiating the contract",id:"step-2-instantiating-the-contract",level:3},{value:"Step 3) Defining the state variables and the constructor",id:"step-3-defining-the-state-variables-and-the-constructor",level:3},{value:"Step 4) Setting the fee payer address through the <code>setDappMetadata</code> function",id:"step-4-setting-the-fee-payer-address-through-the-setdappmetadata-function",level:3},{value:"Step 5) Setting the Gateway address through the <code>setGateway</code> function",id:"step-5-setting-the-gateway-address-through-the-setgateway-function",level:3},{value:"Step 6) Sending a read request to the destination chain",id:"step-6-sending-a-read-request-to-the-destination-chain",level:3},{value:"Step 7) Handling the Acknowledgment",id:"step-7-handling-the-acknowledgment",level:3}],d={toc:c};function u(e){let{components:t,...a}=e;return(0,r.kt)("wrapper",(0,n.Z)({},d,a,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("p",null,"This section explains how to create a simple cross-chain read request contract by integrating the Router Gateway contracts. The assumption made here is that a random contract already exists on the destination chain that retrieves a certain value from the source chain."),(0,r.kt)("h3",{id:"step-1-installing-the-dependencies"},"Step 1) Installing the dependencies"),(0,r.kt)("p",null,"Install the ",(0,r.kt)("inlineCode",{parentName:"p"},"evm-gateway")," contracts with either of the following commands:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"yarn add @routerprotocol/evm-gateway-contracts\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"npm install @routerprotocol/evm-gateway-contracts\n")),(0,r.kt)("admonition",{type:"tip"},(0,r.kt)("p",{parentName:"admonition"},"Make sure you're using the latest version of the Gateway contracts.")),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"step-2-instantiating-the-contract"},"Step 2) Instantiating the contract"),(0,r.kt)("p",null,"Import ",(0,r.kt)("inlineCode",{parentName:"p"},"IGateway.sol")," from ",(0,r.kt)("inlineCode",{parentName:"p"},"@routerprotocol/evm-gateway-contracts/contracts"),":"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'//SPDX-License-Identifier: UNLICENSED\npragma solidity >=0.8.0 <0.9.0;\n\nimport "@routerprotocol/evm-gateway-contracts/contracts/IGateway.sol";\n\ncontract ReadCall {\n}\n')),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"step-3-defining-the-state-variables-and-the-constructor"},"Step 3) Defining the state variables and the constructor"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"IGateway public gatewayContract;\naddress public owner;\nuint256 public value;\n\nevent ReceivedData(uint256 value);\n\nconstructor(\n    address payable gatewayAddress,\n    string memory feePayerAddress\n) {\n    owner = msg.sender;\n    gatewayContract = IGateway(gatewayAddress);\n\n    gatewayContract.setDappMetadata(feePayerAddress);\n}\n")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},"Create an instance of the ",(0,r.kt)("inlineCode",{parentName:"li"},"gatewayContract")," of type ",(0,r.kt)("inlineCode",{parentName:"li"},"IGateway"),". This will be the contract that will route the request to the destination chain."),(0,r.kt)("li",{parentName:"ol"},"Create a variable ",(0,r.kt)("inlineCode",{parentName:"li"},"owner")," of type ",(0,r.kt)("inlineCode",{parentName:"li"},"address")," which will be used for access control."),(0,r.kt)("li",{parentName:"ol"},"Create a variable ",(0,r.kt)("inlineCode",{parentName:"li"},"value")," of type ",(0,r.kt)("inlineCode",{parentName:"li"},"uint256")," which will be used for storing the value that we read from the destination chain. Note that one can read any kind of data from the destination chain contract. "),(0,r.kt)("li",{parentName:"ol"},"Create an event ",(0,r.kt)("inlineCode",{parentName:"li"},"ReceivedData")," with a parameter ",(0,r.kt)("inlineCode",{parentName:"li"},"value")," of type ",(0,r.kt)("inlineCode",{parentName:"li"},"uint256"),". It will be emitted when the data is received from the destination chain."),(0,r.kt)("li",{parentName:"ol"},"Create a constructor with the ",(0,r.kt)("inlineCode",{parentName:"li"},"gatewayAddress")," and the ",(0,r.kt)("inlineCode",{parentName:"li"},"feePayer")," address in string format and set these variables inside the constructor.")),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"step-4-setting-the-fee-payer-address-through-the-setdappmetadata-function"},"Step 4) Setting the fee payer address through the ",(0,r.kt)("inlineCode",{parentName:"h3"},"setDappMetadata")," function"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'function setDappMetadata(\n    string memory FeePayer\n    ) public {\n    require(msg.sender == owner, "Only owner can set the metadata");\n    gatewayContract.setDappMetadata(FeePayer);\n  }\n')),(0,r.kt)("p",null,"To allow your dApp to send cross-chain transactions, you must specify the fee payer address on the Router chain. This can be done by calling the ",(0,r.kt)("inlineCode",{parentName:"p"},"setDappMetadata")," function on the Gateway contract, and passing the fee payer address as a parameter. Once the fee payer address is set, the fee payer must provide approval on the Router chain to confirm their willingness to pay fees for your dApp."),(0,r.kt)("p",null,"It's important to note that any fee refunds will be credited to the fee payer address specified in the ",(0,r.kt)("inlineCode",{parentName:"p"},"setDappMetadata")," function."),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"step-5-setting-the-gateway-address-through-the-setgateway-function"},"Step 5) Setting the Gateway address through the ",(0,r.kt)("inlineCode",{parentName:"h3"},"setGateway")," function"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'function setGateway(address gateway) external {\n    require(msg.sender == owner, "only owner");\n    gatewayContract = IGateway(gateway);\n  }\n')),(0,r.kt)("p",null,"This is an administrative function which sets the address of the Gateway contract. This function should be invoked whenever the Router's Gateway contract gets updated."),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"step-6-sending-a-read-request-to-the-destination-chain"},"Step 6) Sending a read request to the destination chain"),(0,r.kt)("p",null,"Lets say there is a ",(0,r.kt)("inlineCode",{parentName:"p"},"Multiplication")," contract on the destination chain with a function ",(0,r.kt)("inlineCode",{parentName:"p"},"getResult()")," that takes a ",(0,r.kt)("inlineCode",{parentName:"p"},"uint256")," number as parameter and multiplies it with 2 and returns the result."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"contract Multiplication {\n  function getResult(uint256 num) external view returns (uint256) {\n    return num * 2;\n  }\n}\n")),(0,r.kt)("p",null,"To send a read request to the destination chain to get the multiplication of any number, create a ",(0,r.kt)("inlineCode",{parentName:"p"},"getResult")," function along with an interface.\nNext, encode a function call using that interface in the following way:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"interface IMultiplication {\n  function getResult(uint256 num) external view returns (uint256)\n}\n")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'function sendReadRequest(\n  string calldata destChainId,\n  string calldata destinationContractAddress,\n  bytes calldata requestMetadata,\n  uint256 _value\n) public payable {\n  bytes memory packet = abi.encodeCall(IMultiplication.getResult, (_value));\n  bytes memory requestPacket = abi.encode(destinationContractAddress, packet);\n\n  gatewayContract.iSend{ value: msg.value }(\n    1,\n    0,\n    string(""),\n    destChainId,\n    requestMetadata,\n    requestPacket\n  );\n}\n')),(0,r.kt)("p",null,"The parameters:"),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"1) ",(0,r.kt)("inlineCode",{parentName:"strong"},"destChainId")," -")," Chain ID of the destination chain in string format."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"2) ",(0,r.kt)("inlineCode",{parentName:"strong"},"destinationContractAddress")," -")," Address of the contract on the destination chain in string format."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"3) ",(0,r.kt)("inlineCode",{parentName:"strong"},"requestMetadata")," -")," The detailed documentation for the ",(0,r.kt)("inlineCode",{parentName:"p"},"requestMetadata")," function can be found ",(0,r.kt)("a",{parentName:"p",href:"../iDapp-functions/iSend#5-requestmetadata"},"here"),"."),(0,r.kt)("p",null,"To create a read request payload packet, one can encode the function call using the ",(0,r.kt)("inlineCode",{parentName:"p"},"abi.encodeCall")," function in the way provided in the above snippet. Now, to create the final request packet, just ",(0,r.kt)("inlineCode",{parentName:"p"},"abi.encode")," the destination contract address along with the payload packet. Once this is done, we can generate a cross-chain read request by calling the ",(0,r.kt)("inlineCode",{parentName:"p"},"iSend")," function of the Gateway contract with the required parameters. "),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"step-7-handling-the-acknowledgment"},"Step 7) Handling the Acknowledgment"),(0,r.kt)("p",null,"Once the read request is executed on the destination chain, the requested data is sent along with an acknowledgment to the source chain. To handle the acknowledgment, the applications need to include an ",(0,r.kt)("inlineCode",{parentName:"p"},"iAck()")," function in the contract."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"function iAck(\n    uint256 ,//requestIdentifier,\n    bool ,//execFlag,\n    bytes memory execData\n  ) external {\n    value = abi.decode(execData, (uint256));\n\n    emit ReceivedData( value);\n  }\n")),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The function named ",(0,r.kt)("inlineCode",{parentName:"p"},"iAck")," should be created with the same function signature as specified in the documentation. This function is called by the Gateway contract on the source chain and the function name and parameters should not be changed to avoid any failed requests. Further information about this function can be found ",(0,r.kt)("a",{parentName:"p",href:"../iDapp-functions/iAck"},"here"),".")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"requestIdentifier")," parameter received in the ",(0,r.kt)("inlineCode",{parentName:"p"},"iAck")," function contains the nonce that was generated by the Gateway contract when the request was initiated on the source chain.")),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"The ",(0,r.kt)("inlineCode",{parentName:"p"},"execFlag")," tells the execution status of the cross-chain request on the destination chain and ",(0,r.kt)("inlineCode",{parentName:"p"},"execData")," consists of the abi-encoded value returned from the ",(0,r.kt)("inlineCode",{parentName:"p"},"iReceive")," function."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"If the execution is successful on the destination chain:"),"  "),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"execFlag")," - ",(0,r.kt)("inlineCode",{parentName:"li"},"[true]")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"execData")," - ",(0,r.kt)("inlineCode",{parentName:"li"},"(abi.encode(<return_value>))"))),(0,r.kt)("p",{parentName:"li"},"Since the return value is ",(0,r.kt)("inlineCode",{parentName:"p"},"uint256"),", this ",(0,r.kt)("inlineCode",{parentName:"p"},"execData")," can be decoded using abi decoding in the following way:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"uint256 val = abi.decode(execData, (uint256));\n"))),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("p",{parentName:"li"},(0,r.kt)("strong",{parentName:"p"},"If the execution fails on the destination chain:")),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"execFlag")," - ",(0,r.kt)("inlineCode",{parentName:"li"},"[false]")),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"execData")," - ",(0,r.kt)("inlineCode",{parentName:"li"},"[abi.encode(<error>)]"))))))),(0,r.kt)("hr",null),(0,r.kt)("p",null,"In this way, one can create a simple cross-chain read request contract using Router CrossTalk."),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("b",null,"Full read request contract example (to be deployed on the intended source chain)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'//SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.10;\n\nimport "@routerprotocol/evm-gateway-contracts/contracts/IGateway.sol";\n\ninterface IMultiplication {\n  function getResult(uint256 num) external view returns (uint256);\n}\n\ncontract ReadCall {\n    IGateway public gatewayContract;\n    address public owner;\n    uint256 public value;\n\n    event ReceivedData( uint256 value);\n\n    constructor(\n        address payable gatewayAddress,\n        string memory feePayerAddress\n    ) {\n        owner = msg.sender;\n        gatewayContract = IGateway(gatewayAddress);\n\n        gatewayContract.setDappMetadata(feePayerAddress);\n    }\n\n    /// @notice function to set the fee payer address on Router Chain.\n    /// @param feePayerAddress address of the fee payer on Router Chain.\n    function setDappMetadata(string memory feePayerAddress) external {\n        require(msg.sender == owner, "only owner");\n        gatewayContract.setDappMetadata(feePayerAddress);\n    }\n\n    /// @notice function to set the Router Gateway Contract.\n    /// @param gateway address of the gateway contract.\n    function setGateway(address gateway) external {\n        require(msg.sender == owner, "only owner");\n        gatewayContract = IGateway(gateway);\n    }\n\n    /// @notice function to get the request metadata to be used while initiating cross-chain request\n    /// @return requestMetadata abi-encoded metadata according to source and destination chains\n    function getRequestMetadata(\n      uint64 destGasLimit,\n      uint64 destGasPrice,\n      uint64 ackGasLimit,\n      uint64 ackGasPrice,\n      uint128 relayerFees,\n      uint8 ackType,\n      bool isReadCall,\n      bytes memory asmAddress\n      ) public pure returns (bytes memory) {\n      bytes memory requestMetadata = abi.encodePacked(\n          destGasLimit,\n          destGasPrice,\n          ackGasLimit,\n          ackGasPrice,\n          relayerFees,\n          ackType,\n          isReadCall,\n          asmAddress\n      );\n      return requestMetadata;\n    }\n\n    function sendReadRequest(\n        string calldata destChainId,\n        string calldata destinationContractAddress,\n        bytes calldata requestMetadata,\n        uint256 _value\n    ) public payable {\n        bytes memory packet = abi.encodeCall(IMultiplication.getResult, (_value));\n        bytes memory requestPacket = abi.encode(destinationContractAddress, packet);\n\n        gatewayContract.iSend{ value: msg.value }(\n          1,\n          0,\n          string(""),\n          destChainId,\n          requestMetadata,\n          requestPacket\n        );\n    }\n\n    function iAck(\n      uint256 ,//requestIdentifier,\n      bool ,//execFlag,\n      bytes memory execData\n    ) external {\n      value = abi.decode(execData, (uint256));\n\n      emit ReceivedData( value);\n    }\n}\n\n'))),(0,r.kt)("details",null,(0,r.kt)("summary",null,(0,r.kt)("b",null,"Multiplication contract example for reading contract state (to be deployed on the intended destination chain)")),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'//SPDX-License-Identifier: UNLICENSED\n\npragma solidity ^0.8.10;\nimport "./IMultiplication.sol";\n\ncontract Multiplication {\n    function getResult(uint256 num) external view returns (uint256) {\n      return num * 2;\n    }\n}\n'))))}u.isMDXComponent=!0}}]);