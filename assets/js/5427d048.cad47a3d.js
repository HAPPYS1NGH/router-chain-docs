"use strict";(self.webpackChunkrouter_docs=self.webpackChunkrouter_docs||[]).push([[2141],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>p});var r=n(67294);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function c(e,t){if(null==e)return{};var n,r,a=function(e,t){if(null==e)return{};var n,r,a={},i=Object.keys(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)n=i[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var s=r.createContext({}),l=function(e){var t=r.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},d=function(e){var t=l(e.components);return r.createElement(s.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},h=r.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,s=e.parentName,d=c(e,["components","mdxType","originalType","parentName"]),h=l(n),p=a,f=h["".concat(s,".").concat(p)]||h[p]||u[p]||i;return n?r.createElement(f,o(o({ref:t},d),{},{components:n})):r.createElement(f,o({ref:t},d))}));function p(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=h;var c={};for(var s in t)hasOwnProperty.call(t,s)&&(c[s]=t[s]);c.originalType=e,c.mdxType="string"==typeof e?e:a,o[1]=c;for(var l=2;l<i;l++)o[l]=n[l];return r.createElement.apply(null,o)}return r.createElement.apply(null,n)}h.displayName="MDXCreateElement"},77208:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>u,frontMatter:()=>i,metadata:()=>c,toc:()=>l});var r=n(87462),a=(n(67294),n(3905));const i={title:"Handling the Acknowledgment on the Source Chain",sidebar_position:2},o=void 0,c={unversionedId:"cross-chain-read-requests/near_guides/handling-the-acknowledgment-on-the-source-chain",id:"cross-chain-read-requests/near_guides/handling-the-acknowledgment-on-the-source-chain",title:"Handling the Acknowledgment on the Source Chain",description:"Once the read request is executed on the destination chain, the requested data is sent along with an acknowledgment to the source chain. To handle the acknowledgment, developers need to include a handlecrosstalkack() function in their contract. This function will have three parameters, namely:",source:"@site/docs/crosstalk/cross-chain-read-requests/near_guides/handling-the-acknowledgment-on-the-source-chain.md",sourceDirName:"cross-chain-read-requests/near_guides",slug:"/cross-chain-read-requests/near_guides/handling-the-acknowledgment-on-the-source-chain",permalink:"/crosstalk/cross-chain-read-requests/near_guides/handling-the-acknowledgment-on-the-source-chain",draft:!1,editUrl:"https://github.com/router-protocol/docs/tree/main/docs/crosstalk/cross-chain-read-requests/near_guides/handling-the-acknowledgment-on-the-source-chain.md",tags:[],version:"current",sidebarPosition:2,frontMatter:{title:"Handling the Acknowledgment on the Source Chain",sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Creating and Sending a Cross-chain Read Request",permalink:"/crosstalk/cross-chain-read-requests/near_guides/creating-and-sending-a-cross-chain-read-request"},next:{title:"Guides",permalink:"/crosstalk/category/guides"}},s={},l=[{value:"1. event_identifier",id:"1-event_identifier",level:3},{value:"2. exec_flags",id:"2-exec_flags",level:3},{value:"3. exec_data",id:"3-exec_data",level:3}],d={toc:l};function u(e){let{components:t,...n}=e;return(0,a.kt)("wrapper",(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,a.kt)("p",null,"Once the read request is executed on the destination chain, the requested data is sent along with an acknowledgment to the source chain. To handle the acknowledgment, developers need to include a ",(0,a.kt)("inlineCode",{parentName:"p"},"handle_crosstalk_ack()")," function in their contract. This function will have three parameters, namely:"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-javascript"},"fn handle_crosstalk_ack(\n    &self,\n    event_identifier: u64,\n    exec_flags: Vec<bool>,\n    exec_data: Vec<Vec<u8>>,\n)\n")),(0,a.kt)("h3",{id:"1-event_identifier"},"1. event_identifier"),(0,a.kt)("p",null,"This is the same nonce you receive while calling the ",(0,a.kt)("inlineCode",{parentName:"p"},"read_query_to_dest()")," function on the source chain Gateway contract. Using this nonce, you can verify whether a particular request was executed on the destination chain."),(0,a.kt)("h3",{id:"2-exec_flags"},"2. exec_flags"),(0,a.kt)("p",null,"Since multiple payloads can be sent to multiple contract addresses on the destination chain, the ",(0,a.kt)("inlineCode",{parentName:"p"},"exec_flags")," is an array of boolean values that tells you the status of the individual calls."),(0,a.kt)("h3",{id:"3-exec_data"},"3. exec_data"),(0,a.kt)("p",null,"The ",(0,a.kt)("inlineCode",{parentName:"p"},"exec_data")," parameter is an array of bytes that provides the return values from every read call included in the read request. Based on the application's requirement, this data can be decoded and processed on the source chain."))}u.isMDXComponent=!0}}]);