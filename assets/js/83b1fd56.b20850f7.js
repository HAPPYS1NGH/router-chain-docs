"use strict";(self.webpackChunkrouter_docs=self.webpackChunkrouter_docs||[]).push([[1332],{3905:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>h});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function s(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):s(s({},t),e)),n},d=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,c=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),u=l(n),h=r,m=u["".concat(c,".").concat(h)]||u[h]||p[h]||i;return n?a.createElement(m,s(s({ref:t},d),{},{components:n})):a.createElement(m,s({ref:t},d))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,s=new Array(i);s[0]=u;var o={};for(var c in t)hasOwnProperty.call(t,c)&&(o[c]=t[c]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var l=2;l<i;l++)s[l]=n[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},32962:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var a=n(87462),r=(n(67294),n(3905));const i={title:"i_send",sidebar_position:1},s="i_send Function",o={unversionedId:"message-transfer-via-crosstalk/near-guides/iDapp-functions/i_send",id:"message-transfer-via-crosstalk/near-guides/iDapp-functions/i_send",title:"i_send",description:"This function allows users to configure various aspects of cross-chain message passing based on their requirements. Some of the parameters that can be configured while calling this function include:",source:"@site/docs/develop/message-transfer-via-crosstalk/near-guides/iDapp-functions/i_send.md",sourceDirName:"message-transfer-via-crosstalk/near-guides/iDapp-functions",slug:"/message-transfer-via-crosstalk/near-guides/iDapp-functions/i_send",permalink:"/develop/message-transfer-via-crosstalk/near-guides/iDapp-functions/i_send",draft:!1,editUrl:"https://github.com/router-protocol/docs/tree/main/docs/develop/message-transfer-via-crosstalk/near-guides/iDapp-functions/i_send.md",tags:[],version:"current",sidebarPosition:1,frontMatter:{title:"i_send",sidebar_position:1},sidebar:"tutorialSidebar",previous:{title:"NEAR iDapp Functions",permalink:"/develop/message-transfer-via-crosstalk/near-guides/iDapp-functions/"},next:{title:"burn_and_call_gateway",permalink:"/develop/message-transfer-via-crosstalk/near-guides/iDapp-functions/burn_and_call_gateway"}},c={},l=[{value:"1) <code>version</code>",id:"1-version",level:3},{value:"2) <code>dest_chain_id</code>",id:"2-dest_chain_id",level:3},{value:"3) <code>request_metadata</code>",id:"3-request_metadata",level:3},{value:"4) <code>request_packet</code>",id:"4-request_packet",level:3}],d={toc:l};function p(e){let{components:t,...n}=e;return(0,r.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"i_send-function"},(0,r.kt)("inlineCode",{parentName:"h1"},"i_send")," Function"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"#[payable]\npub fn i_send(\n   &mut self,\n   version: U128,\n   dest_chain_id: String,\n   request_metadata: Vec<u8>,\n   request_packet: Vec<u8>\n) -> U128\n")),(0,r.kt)("p",null,"This function allows users to configure various aspects of cross-chain message passing based on their requirements. Some of the parameters that can be configured while calling this function include:"),(0,r.kt)("h3",{id:"1-version"},"1) ",(0,r.kt)("inlineCode",{parentName:"h3"},"version")),(0,r.kt)("p",null,"The current version of the Gateway contract which can be obtained by calling a specific function within the Gateway contract."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"pub fn get_current_version(&self) -> U128\n")),(0,r.kt)("p",null,"This would change whenever the encoding of ",(0,r.kt)("inlineCode",{parentName:"p"},"request_metadata")," (parameter #5) changes. However, to remain compatible with iDapps configured to work with previous versions, Router will also support earlier versions of encoding."),(0,r.kt)("h3",{id:"2-dest_chain_id"},"2) ",(0,r.kt)("inlineCode",{parentName:"h3"},"dest_chain_id")),(0,r.kt)("p",null,"Chain ID of the destination chain in string format."),(0,r.kt)("h3",{id:"3-request_metadata"},"3) ",(0,r.kt)("inlineCode",{parentName:"h3"},"request_metadata")),(0,r.kt)("p",null,"To avoid encoding on-chain, Router allows iDapps to send static information for a request as a parameter to their iDapp, which depends upon the destination chain ID provided by the user. This information is packaged into a byte-encoded string, known as the ",(0,r.kt)("inlineCode",{parentName:"p"},"request_metadata")," which includes the following parameters:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"dest_gas_limit: u64,\ndest_gas_price: u64,\nack_gas_limit: u64,\nack_gas_price: u64,\nrelayer_fees: U128,\nack_type: u8,\nis_read_call: bool,\nasm_address: String\n")),(0,r.kt)("p",null,"It can be achieved by adding the following function in your contract:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"fn get_request_metadata(\n   dest_gas_limit: u64,\n   dest_gas_price: u64,\n   ack_gas_limit: u64,\n   ack_gas_price: u64,\n   relayer_fees: U128,\n   ack_type: u8,\n   is_read_call: bool,\n   asm_address: String\n) -> Vec<u8> {\n   let mut request_metadata: Vec<u8> = vec![];\n\n   request_metadata.append(&mut dest_gas_limit.to_be_bytes().to_vec());\n   request_metadata.append(&mut dest_gas_price.to_be_bytes().to_vec());\n   request_metadata.append(&mut ack_gas_limit.to_be_bytes().to_vec());\n   request_metadata.append(&mut ack_gas_price.to_be_bytes().to_vec());\n   request_metadata.append(&mut u128::from(relayer_fees).to_be_bytes().to_vec());\n   request_metadata.append(&mut ack_type.to_be_bytes().to_vec());\n\n   if is_read_call {\n      request_metadata.append(&mut vec![1]);\n   } else {\n      request_metadata.append(&mut vec![0]);\n   }\n   request_metadata.append(&mut asm_address.as_bytes().to_vec());\n\n   request_metadata\n}\n")),(0,r.kt)("p",null,"Alternatively, the ",(0,r.kt)("inlineCode",{parentName:"p"},"request_metadata")," parameter can be created in TypeScript or JavaScript using the following function:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"function getRequestMetadata(\n  destGasLimit: number,\n  destGasPrice: number,\n  ackGasLimit: number,\n  ackGasPrice: number,\n  relayerFees: string,\n  ackType: number,\n  isReadCall: boolean,\n  asmAddress: string\n): string {\n  return ethers.utils.solidityPack(\n    [\n      'uint64',\n      'uint64',\n      'uint64',\n      'uint64',\n      'uint128',\n      'uint8',\n      'bool',\n      'string',\n    ],\n    [\n      destGasLimit,\n      destGasPrice,\n      ackGasLimit,\n      ackGasPrice,\n      relayerFees,\n      ackType,\n      isReadCall,\n      asmAddress,\n    ]\n  );\n}\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"3.1) ",(0,r.kt)("inlineCode",{parentName:"strong"},"dest_gas_limit")," -")," Gas limit required for execution of the request on the destination chain."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"3.2) ",(0,r.kt)("inlineCode",{parentName:"strong"},"dest_gas_price")," -")," Gas price of the destination chain. This can be calculated using the RPC of destination chain. If you don\u2019t want to calculate it, just send ",(0,r.kt)("strong",{parentName:"p"},"0")," in its place and the Router chain will estimate the real time gas price for you."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"3.3) ",(0,r.kt)("inlineCode",{parentName:"strong"},"ack_gas_limit")," -")," Gas limit required for the execution of the acknowledgment on the source chain. This can be calculated using tools like ",(0,r.kt)("a",{parentName:"p",href:"https://www.npmjs.com/package/hardhat-gas-reporter"},"hardhat-gas-reporter"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"3.4) ",(0,r.kt)("inlineCode",{parentName:"strong"},"ack_gas_price")," -")," Gas price of the source chain. This can be calculated using the RPC of source chain. To avoid the need for calculation, it can be passed as 0. The Router chain will then estimate the real-time gas price for them."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"3.5) ",(0,r.kt)("inlineCode",{parentName:"strong"},"relayer_fees")," -")," This parameter functions similarly to the priority fees on other blockchain networks. Since the Router chain relayers handle the execution of cross-chain requests on the destination chain, setting a higher ",(0,r.kt)("inlineCode",{parentName:"p"},"relayer_fees")," will increase the likelihood of your request being prioritized by relayers. If a very low ",(0,r.kt)("inlineCode",{parentName:"p"},"relayer_fees")," is provided, the Router chain will automatically adjust it to the minimum required amount to ensure that it is executed. If it is passed as 0, the Router chain will default it to the minimum set Relayer fee value."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"3.6) ",(0,r.kt)("inlineCode",{parentName:"strong"},"ack_type")," -")," When the contract calls have been executed on the destination chain, the destination chain Gateway contract sends an acknowledgent back to the Router chain. iDapps have the option to get this acknowledgment from the Router chain to the source chain and execute some operations based on the ack."),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"If ",(0,r.kt)("inlineCode",{parentName:"li"},"ack_type")," = 0, the user doesn't want the acknowledgment to be forwarded back to the source chain."),(0,r.kt)("li",{parentName:"ul"},"If ",(0,r.kt)("inlineCode",{parentName:"li"},"ack_type")," = 1, the acknowledgment is expected to be received only if the calls were successfully executed on the destination chain, and the user intends to perform some operation on the source chain after receiving the ack."),(0,r.kt)("li",{parentName:"ul"},"If ",(0,r.kt)("inlineCode",{parentName:"li"},"ack_type")," = 2, an acknowledgment is needed only in case of an error occurring on the destination chain. This options also allows for execution of certain operations after receiving the ack."),(0,r.kt)("li",{parentName:"ul"},"If ",(0,r.kt)("inlineCode",{parentName:"li"},"ack_type")," = 3, an acknowledgment is needed from the destination chain regardless of whether the call succeeds or fails, and some operations need to be performed based on the ack. ")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"3.7) ",(0,r.kt)("inlineCode",{parentName:"strong"},"is_read_call")," -")," Router provides dApps an option to query a contract on another chain and receive the data back on the source chain as an acknowledgment. If the intention is only to query a contract on the destination chain and not perform any write operation there, then set this option to ",(0,r.kt)("inlineCode",{parentName:"p"},"true"),"."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"3.8) ",(0,r.kt)("inlineCode",{parentName:"strong"},"asm_address")," -")," As part of Router's modular security framework, developers can integrate an ASM module to add an extra layer of security on top of the infra-level security provided by the Router Chain. These modules will be in the form of smart contracts on the destination chain, and their addresses should be passed as bytes in this variable. Documentation for ASM can be found ",(0,r.kt)("a",{parentName:"p",href:"../../key-concepts/additional-security-modules"},"here"),"."),(0,r.kt)("h3",{id:"4-request_packet"},"4) ",(0,r.kt)("inlineCode",{parentName:"h3"},"request_packet")),(0,r.kt)("p",null,"This is bytes encoded string consisting of two parameters:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"dest_contract_address: String,\npayload: Vec<u8>\n")),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"4.1) ",(0,r.kt)("inlineCode",{parentName:"strong"},"dest_contract_address")," -")," This is the address of the destination chain's smart contract that will handle the payload sent from the source chain to the destination chain."),(0,r.kt)("p",null,(0,r.kt)("strong",{parentName:"p"},"4.2) ",(0,r.kt)("inlineCode",{parentName:"strong"},"payload")," -")," Bytes containing the payload that you want to send to the destination chain. This can be anything depending on your utility. For example, in the case of NFT transfers, it can contain the NFT ID, the recipient address etc. "),(0,r.kt)("p",null,"In other words, payload is the data that you will receive on the destination chain as packet. For transferring an NFT with a specific NFT ID and recipient address, the request packet can be created using the following code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},'use ethabi::{ ethereum_types::U256, encode, Token };\n\npub fn get_request_packet(\n   destination_contract_address: String\n) -> Vec<u8> {\n      // Here we are passing NFT ID and the recipient address as packet.\n      // However you can pass any other data as well.\n      let nft_id: u64 = 1;\n      let recipient_address = "RECIPIENT_ADDRESS";\n\n      let nft_id_u256: U256 = ethabi::ethereum_types::U256::from(ack_request_identifier);\n      let nft_id_token: Token = Token::Uint(nft_id_u256);\n      let recipient_token: Token = Token::String(recipient_address);\n\n      let packet: Vec<u8> = encode(&[nft_id_token, recipient_token]);\n      let packet_token = Token::Bytes(packet);\n      let dest_contract_address_token: Token = Token::String(destination_contract_address);\n\n      let request_packet: Vec<u8> = encode(&[dest_contract_address_token, packet_token]);\n\n      request_packet\n}\n')),(0,r.kt)("p",null,"   In this snippet, we are using the following version for ethabi:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-javascript"},"use ethabi::{ ethereum_types::U256, encode, Token };\n")),(0,r.kt)("p",null,"After you call this function, a cross-chain request is created and relayed via the Router chain to the destination chain where the ",(0,r.kt)("inlineCode",{parentName:"p"},"i_receive")," function is called on the destination contract address passed in the ",(0,r.kt)("inlineCode",{parentName:"p"},"request_packet"),"."))}p.isMDXComponent=!0}}]);